#!/bin/bash
# imosh is a utility library for BASH.
#
# For more details, see https://github.com/imos/imosh

IMOSH_VERSION='2014-11-07 06:04:17 +0900 (6ace594)'

# Enables error checking if imosh is called in a script.
if ! shopt login_shell >/dev/null; then
  # Make a script fail when
  # - a command returns non-zero value (-e).
  # - an undefined variable is referred (-u).
  set -e -u
  # Return if imosh is already loaded.
  if [ "${__IMOSH_IS_LOADED+loaded}" = 'loaded' ]; then
    return
  fi
fi

# array -- Creates an array.
#
# array creates an array from a string with IFS separators.
#
# Usage:
#     // 1. Function form
#     void func::array(string[]* result, string input)
func::array() {
  if [ "$#" -eq 2 ]; then
    local __array_ifs="${IFS}"
    __array_ifs="${__array_ifs//'['/\[}"
    __array_ifs="${__array_ifs//']'/\]}"
    func::greg_split "${1}" "[${__array_ifs}]" "${2}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# array_keys -- Gets an array's keys.
#
# array_keys gets an array's keys.
#
# Usage:
#     // 1. Function form.
#     void func::array_keys(string[]* output, string[]* input)
#     // 2. Command form.
#     void sub::array_keys(string[]* input) > output
func::array_keys() {
  if [ "$#" -eq 2 ]; then
    if eval "[ \"\${#${2}[*]}\" -eq 0 ]"; then
      eval "${1}=()"
    else
      eval "${1}=(\"\${!${2}[@]}\")"
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::array_keys() {
  if [ "$#" -eq 1 ]; then
    local __array_keys_values=()
    func::array_keys __array_keys_values "${1}"
    sub::println "${__array_keys_values[*]}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}
# array_map -- Applies a callback to elements.
#
# array_map applies a callback to every element.  stream::array_map applies a
# callback to every line's elements.
# stream::array_map supports the following functions: array, function, inplace
# and command.
#
# Usage:
#     // 1. Function form.
#     void func::array_map(string[]* variable, string type,
#                          string callback [, string arguments...])
#     // 2. Stream form.
#     void stream::array_map(
#         string type, string callback [, string arguments...])
#         < input > output
#
# Type:
# - ARRAY
#     Reads every line as an array, and applies a callback to every line.
# - FUNCTION
#     Reads every line as a string and applies a callback.  A callback should be
#     a function format like: function(string* output, input).
# - INPLACE
#     Reads every line as a string and applies a callback.  A callback should be
#     an inplace format like: function(string* input_and_output).
# - COMMAND
#     Reads every line as a string and applies a callback.  A callback should be
#     a command format like: function(string input) > output.
#
# Examples:
#     input=('abc' 'DeF' '012')
#     func::array_map input INPLACE func::strtoupper
#     echo "${input[@]}" # => ABC DEF 012
#
#     sub::print $'def,abc,ghi\n1,3,2,5,4' | \
#         IFS=',' stream::array_map ARRAY func::sort
#         # => abc,def,ghi\n1,2,3,4,5
#
#     sub::print $'abcbd\nbcdbcb' | \
#         stream::array_map INPLACE func::str_replace 'bc' 'BC'
#         # => aBCbd\nBCdBCb
func::array_map() {
  if [ "$#" -ge 3 ]; then
    # Return if there are no elements in the variable.
    if eval "[ \"\${#${1}[*]}\" -eq 0 ]"; then
      return
    fi

    local __array_map_variable="$1"; shift
    local __array_map_type="$1"; shift
    local __array_map_callback="$1"; shift

    local __array_map_keys=()
    local __array_map_key=''
    func::array_keys __array_map_keys "${__array_map_variable}"
    case "${__array_map_type}" in
      'ARRAY')
        local __array_map_value=''
        local __array_map_array_value=()
        for __array_map_key in "${__array_map_keys[@]}"; do
          func::strcpy __array_map_value \
                       "${__array_map_variable}[${__array_map_key}]"
          func::array __array_map_array_value "${__array_map_value}"
          "${__array_map_callback}" __array_map_array_value "$@"
          func::let "${__array_map_variable}[${__array_map_key}]" \
                    "${__array_map_array_value[*]}"
        done
        ;;
      'FUNCTION')
        local __array_map_value=''
        for __array_map_key in "${__array_map_keys[@]}"; do
          func::strcpy __array_map_value \
                       "${__array_map_variable}[${__array_map_key}]"
          "${__array_map_callback}" \
              "${__array_map_variable}[${__array_map_key}]" \
              "${__array_map_value}" \
              "$@"
        done
        ;;
      'INPLACE')
        local __array_map_value=''
        for __array_map_key in "${__array_map_keys[@]}"; do
          "${__array_map_callback}" \
              "${__array_map_variable}[${__array_map_key}]" \
              "$@"
        done
        ;;
      'COMMAND')
        local __array_map_value=''
        local __array_map_tmpfile=''
        func::tmpfile __array_map_tmpfile
        for __array_map_key in "${__array_map_keys[@]}"; do
          func::strcpy __array_map_value \
                       "${__array_map_variable}[${__array_map_key}]"
          "${__array_map_callback}" \
              "${__array_map_value}" \
              "$@" > "${__array_map_tmpfile}"
          func::file_get_contents \
              "${__array_map_variable}[${__array_map_key}]" \
              "${__array_map_tmpfile}"
        done
        ;;
      *)
        LOG ERROR "Unknown array_map type: ${__array_map_type}"
        return 2
        ;;
    esac
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

stream::array_map() {
  if [ "$#" -ge 2 ]; then
    local __array_map_type="$1"
    local LINE='' NEWLINE=''
    while func::readline; do
      local __array_map_line=("${LINE}")
      func::array_map __array_map_line "$@"
      if [ "${__array_map_type}" = 'COMMAND' ]; then
        sub::print "${__array_map_line[0]}"
      else
        sub::print "${__array_map_line[0]}${NEWLINE}"
      fi
    done
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# array_unique -- Removes duplicated elements from an array variable.
#
# array_unique sorts elements first and removes duplicated elements.  Function
# form applies array_unique to the given variable.  Stream form applies
# array_unique to every line.  Every line is treated as elements.
#
# Usage:
#     // 1. Function form.
#     void func::array_unique(string[]* variable)
#     // 2. Stream form.
#     void stream::array_unique() < input > output
#
# Examples:
#     a=(c b a b)
#     func::array_unique a
#     echo "${a[@]}"  # => a b c
#
#     echo c b a b | stream::array_unique  # => a b c
#
#     echo c,b,a,b | IFS=, stream::array_unique  # => a,b,c
func::array_unique() {
  local __array_unique_variable="${1}"
  if eval "[ \"\${#${__array_unique_variable}[*]}\" -eq 0 ]"; then
    return
  fi
  eval "local __array_unique_values=(\"\${${__array_unique_variable}[@]}\")"
  func::sort __array_unique_values
  local __array_unique_i=0
  local __array_unique_size="${#__array_unique_values[*]}"
  local __array_unique_result=("${__array_unique_values[0]}")
  while (( __array_unique_i += 1, __array_unique_i < __array_unique_size )); do
    if [ "${__array_unique_values[$(( __array_unique_i - 1 ))]}" != \
         "${__array_unique_values[${__array_unique_i}]}" ]; then
      __array_unique_result+=("${__array_unique_values[${__array_unique_i}]}")
    fi
  done
  eval "${__array_unique_variable}=(\"\${__array_unique_result[@]}\")"
}

stream::array_unique() {
  if [ "$#" -eq 0 ]; then
    stream::array_map ARRAY func::array_unique
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# array_values -- Copies elements from an array to an array.
#
# array_values copies elements in an array variable into an array variable.
#
# Usage:
#     // 1. Function form
#     void func::array_values(string[]* output, string[]* input)
func::array_values() {
  if [ "$#" -eq 2 ]; then
    if eval "[ \"\${#${2}[*]}\" -eq 0 ]"; then
      eval "${1}=()"
    else
      eval "${1}=(\"\${${2}[@]}\")"
    fi
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# count -- Counts the number of elements.
#
# count counts the number of elements of an array.
#
# Usage:
#     // 1. Function form
#     void func::count(int* result, string[]* values)
#     // 2. Command form
#     void sub::count(string[]* values) > result
func::count() {
  if [ "$#" -eq 2 ]; then
    func::strcpy "${1}" "#${2}[*]"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

sub::count() {
  if [ "$#" -eq 1 ]; then
    eval "sub::println \"\${#${1}[*]}\""
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# sort -- Sorts elements.
#
# sort sorts elements.  The function form sorts elements in a variable in place.
# The stream form applies sort to every line.  Every line is treated as
# elements.
#
# Usage:
#     // 1. Function form.
#     void func::sort(string[]* variable)
#     // 2. Stream form.
#     void stream::sort() < input > output
func::sort() {
  local __sort_name="${1}"
  eval "local __sort_size=\"\${#${__sort_name}[*]}\""
  if [ "${__sort_size}" -lt 2 ]; then
    return
  fi
  eval "local __sort_values=(\"\${${__sort_name}[@]}\")"
  __func::quick_sort
  eval "${__sort_name}=(\"\${__sort_values[@]}\")"
}

stream::sort() {
  if [ "$#" -eq 0 ]; then
    stream::array_map ARRAY func::sort
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

__func::quick_sort() {
  local size="${#__sort_values[@]}"
  local pivot="${__sort_values[$(( size / 2 ))]}"
  local values1=() values2=() values3=()

  for value in "${__sort_values[@]}"; do
    if [ "${value}" \< "${pivot}" ]; then
      values1+=("${value}")
    elif [ "${value}" \> "${pivot}" ]; then
      values3+=("${value}")
    else
      values2+=("${value}")
    fi
  done
  func::sort values1
  func::sort values3
  __sort_values=()
  if [ "${#values1[*]}" -ne 0 ]; then
    __sort_values+=("${values1[@]}")
  fi
  if [ "${#values2[*]}" -ne 0 ]; then
    __sort_values+=("${values2[@]}")
  fi
  if [ "${#values3[*]}" -ne 0 ]; then
    __sort_values+=("${values3[@]}")
  fi
}

# fgets -- Gets a line from STDIN.
#
# fgets reads a line and regards it as a result.  fgets does not strip a
# trailing new line.  The function form sets the result to a variable.  The
# subroutine form outputs the result to the standard output.
#
# Usage:
#     // 1. Function form.
#     bool func::fgets(string* variable)
#     // 2. Subroutine form.
#     bool sub::fgets() > line
func::fgets() {
  if [ "$#" -eq 1 ]; then
    local __fgets_variable="$1"
    local __fgets_buffer=''
    local __fgets_line=''

    func::let "${__fgets_variable}" ''
    if ! IFS= read -r -n 1 -d '' __fgets_buffer; then
      return 1
    fi
    __fgets_line+="${__fgets_buffer}"
    if [ "${__fgets_buffer}" = $'\n' ]; then
      func::strcpy "${__fgets_variable}" __fgets_buffer
      return
    fi
    if IFS= read -r -d $'\n' __fgets_buffer; then
      __fgets_buffer+=$'\n'
    fi
    __fgets_line+="${__fgets_buffer}"
    func::strcpy "${__fgets_variable}" __fgets_line
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

sub::fgets() {
  if [ "$#" -eq 0 ]; then
    local variable=''
    if ! func::fgets variable; then
      return 1
    fi
    sub::print "${variable}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# file_get_contents -- Reads an entire file into a string.
#
# The function form reads an entire file and sets its contents to the
# variable.  The subroutine form reads an entire file and outputs its contents
# to the standard output.  The stream form reads a file name for each line and
# outputs its contents to the standard output.
#
# Usage:
#     // 1. Function form.
#     func::file_get_contents(string* variable, string filename)
#     // 2. Subroutine form.
#     sub::file_get_contents(string filename) > output
#     // 3. Stream form.
#     stream::file_get_contents() < input > output
#
# Examples:
#     sub::print hello > "${TMPDIR}/foo"
#     func::file_get_contents variable "${TMPDIR}/foo"
#     echo "${variable}"  # => hello
#
#     sub::print hello > "${TMPDIR}/foo"
#     sub::file_get_contents "${TMPDIR}/foo"  # => hello
#
#     sub::print hello > "${TMPDIR}/foo"
#     sub::print world > "${TMPDIR}/bar"
#     { echo "${TMPDIR}/foo"; echo "${TMPDIR}/bar"; } | \
#         stream::file_get_contents  # => helloworld
func::file_get_contents() {
  if [ "$#" -eq 2 ]; then
    local __file_get_contents_variable="$1"
    local __file_get_contents_filename="$2"

    IFS= read -r -d '' "${__file_get_contents_variable}" \
        < "${__file_get_contents_filename}" || true
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

sub::file_get_contents() {
  if [ "$#" -eq 1 ]; then
    local __file_get_contents_filename="$1"
    cat < "${__file_get_contents_filename}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

stream::file_get_contents() {
  if [ "$#" -eq 0 ]; then
    stream::array_map COMMAND cat
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# readarray -- Reads a line as an array.
#
# readarray reads a line and sets its content to LINE and its trailing new line
# to NEWLINE.
#
# Usage:
#     void func::readarray() < input
func::readarray() {
  if [ "$#" -eq 0 ]; then
    local line=''
    NEWLINE=''
    LINE=''
    if ! func::readline; then
      LINE=()
      return 1
    fi
    local ifs="${IFS}"
    ifs="${ifs//'['/\[}"
    ifs="${ifs//']'/\]}"
    func::greg_split LINE "[${ifs}]" "${LINE}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# readline -- Gets a line.
#
# readline reads a line and sets its content to LINE and its trailing new line
# to NEWLINE.
#
# Usage:
#     void func::readline() < input
func::readline() {
  if [ "$#" -eq 0 ]; then
    local line=''
    NEWLINE=''
    LINE=''
    if ! func::fgets line; then
      return 1
    fi
    if [ "${line:$((${#line} - 2))}" = $'\r\n' ]; then
      NEWLINE=$'\r\n'
      LINE="${line%$'\r\n'}"
    elif [ "${line:$((${#line} - 1))}" = $'\n' ]; then
      NEWLINE=$'\n'
      LINE="${line%$'\n'}"
    else
      NEWLINE=''
      LINE="${line}"
    fi
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# tmpfile -- Creates a temporary file.
#
# tmpfile creates a temporary file with a unique name under ${TMPDIR}.
#
# Usage:
#     // 1. Function form.
#     void func::tmpfile(string* path)
#     // 2. Command form.
#     void sub::tmpfile() > path
func::tmpfile() {
  if [ "${#}" -eq 1 ]; then
    local __tmpfile_variable="${1}"
    func::let "${__tmpfile_variable}" \
        "${TMPDIR}/tmpfile.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::tmpfile() {
  if [ "${#}" -eq 0 ]; then
    local tmpfile=''
    func::tmpfile tmpfile
    sub::println "${tmpfile}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# func::greg_match -- Checks if a string matches a GREG pattern.
#
# greg_match checks if a string matches a GREG pattern.
#
# Usage:
#     // 1. Function form.
#     void func::greg_match(string pattern, string subject)
func::greg_match() {
  if ! shopt extglob > /dev/null; then
    shopt -s extglob
    local result=0
    func::greg_match "$@" || result="$?"
    shopt -u extglob
    return "${result}"
  fi

  if [ "$#" -eq 2 ]; then
    local __greg_match_pattern="${1}"
    local __greg_match_subject="${2}"

    if [[ "${__greg_match_subject}" = ${__greg_match_pattern} ]]; then
      return 0
    else
      return 1
    fi
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::greg_replace -- Replace a GREG pattern with a string.
#
# greg_replace replaces substrings matching a pattern with a string.
#
# Usage:
#     void func::greg_replace(string* subject, string pattern, string replace)
func::greg_replace() {
  if ! shopt extglob >/dev/null; then
    shopt -s extglob
    func::greg_replace "$@"
    shopt -u extglob
    return "$?"
  fi

  if [ "$#" -eq 3 ]; then
    local __greg_replace_subject_variable="${1}"
    local __greg_replace_search="${2}"
    local __greg_replace_replace="${3}"

    eval "${__greg_replace_subject_variable}=\"\${${__greg_replace_subject_variable}//\${__greg_replace_search}/\${__greg_replace_replace}}\""
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::greg_split -- Splits a string with a GREG pattern.
#
# greg_split splits a string with a GREG pattern.
#
# Usage:
#     void func::greg_split(string* variable, string pattern, string value)
func::greg_split() {
  if [ "$#" -eq 3 ]; then
    local __greg_split_variable="$1"
    local __greg_split_pattern="$2"
    local __greg_split_value="$3"

    func::greg_replace __greg_split_value "${__greg_split_pattern}" $'\x02'
    func::explode "${__greg_split_variable}" $'\x02' "${__greg_split_value}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::getchildpids -- Gets child process IDs.
#
# Usage:
#     void func::getchildpids(int[]* variable)
func::getchildpids() {
  if [ "$#" -eq 1 ]; then
    local __getchildpids_variable="$1"
    local __getchildpids_mypid=''
    func::getmypid __getchildpids_mypid
    local __getchildpids_pid='' __getchildpids_ppid=''
    local __getchildpids_result=()
    while IFS=$' \t\n' \
          read -r -d $'\n' __getchildpids_ppid __getchildpids_pid; do
      if [ "${__getchildpids_ppid}" = "${__getchildpids_mypid}" ]; then
        __getchildpids_result+=("${__getchildpids_pid}")
      fi
    done < <(ps -o ppid,pid)
    if [ "${#__getchildpids_result[*]}" -eq 0 ]; then
      eval "${__getchildpids_variable}=()"
    else
      eval "${__getchildpids_variable}=(\"\${__getchildpids_result[@]}\")"
    fi
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::getmypid -- Gets the current process ID.
#
# Usage:
#     void func::pid(int* variable)
func::getmypid() {
  if [ "$#" -eq 1 ]; then
    local __getmypid_variable="$1"
    if func::isset BASHPID; then
      func::let "${__getmypid_variable}" "${BASHPID}"
    else
      local __getmypid_pid_file=''
      func::tmpfile __getmypid_pid_file
      "${SHELL}" -c 'echo "${PPID}"' > "${__getmypid_pid_file}"
      read -r -d $'\n' "${__getmypid_variable}" < "${__getmypid_pid_file}"
    fi
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::rand -- Generates a random integer.
#
# Generates a random integer.
#
# Usage:
#     // a. Function form.
#     void func::rand(int* variable)
#     // b. Function form with a range.
#     void func::rand(int* variable, int minimum, int maximum)
func::rand() {
  if [ "$#" -eq 3 ]; then
    local __rand_variable="$1"
    local __rand_minimum="$2"
    local __rand_maximum="$3"
    local __rand_range=0 __rand_value=0
    if (( __rand_minimum > __rand_maximum )); then
      LOG FATAL "minimum must be larger than maximum:" \
                "minimum=${__rand_minimum}, maximum=${__rand_maximum}"
    fi
    ((
      __rand_value = RANDOM ^ (RANDOM << 8) ^
                     (RANDOM << 16) ^ (RANDOM << 24) ^
                     (RANDOM << 32) ^ (RANDOM << 40) ^
                     (RANDOM << 48) ^ (RANDOM << 56),
      __rand_range = __rand_maximum - __rand_minimum + 1,
      __rand_value = __rand_minimum +
          ( __rand_value % __rand_range + __rand_range ) % __rand_range
    )) || true
    func::let "${__rand_variable}" "${__rand_value}"
  elif [ "$#" -eq 1 ]; then
    func::rand "$1" 0 2147483647
    return
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::atexit -- Registers a function on shutdown.
#
# atexit registers a function to be excuted on shutdown.
#
# Usage:
#     void func::atexit(string command)
func::atexit() {
  if [ "$#" -eq 1 ]; then
    echo "$1" >> "${__IMOSH_CORE_TMPDIR}/atexit.sh"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# exit, die -- Kills the current script.
#
# func::exit kills all the subprocesses of the current program.  If an integer
# argument is given, func::exit exits with the status.  Otherwise, func::exit
# shows the given message and exits with status 0.  func::die shows a stack
# trace and delegates arguments to func::exit.
#
# Usage:
#     // 1-a. Function form with a message.
#     void func::exit(string message)
#     // 1-b. Function form with a status.
#     void func::exit(int status = 0)
#     // 1-c. Function form with a message.
#     void func::die(string message)
#     // 1-d. Function form with a status.
#     void func::die(int status = 0)
func::exit() {
  if [ "$#" -eq 1 ]; then
    local status=0
    if [[ "$1" =~ ^[0-9]+$ ]]; then
      status="$1"
    else
      local message="$1"
      func::rtrim message
      sub::println "${message}"
    fi
    imosh::exit "${status}"
  elif [ "$#" -eq 0 ]; then
    func::exit 0
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

func::die() {
  imosh::stack_trace "*** imosh::die stack trace: ***"
  func::exit "$@"
}

# func::throttle -- Throttles by the number of child processes.
#
# throttle waits that the number of the child processes is less than a limit.
# Firstly, throttle waits for 0.1 second, and the n-th retry (n < 10) waits for
# n * 0.1 seconds.  The n-th retry (n >= 10) waits for 1 second.
#
# Usage:
#     void func::throttle(int limit)
func::throttle() {
  if [ "$#" -eq 1 ]; then
    local __throttle_limit="$1"
    local __throttle_pids=()
    local __throttle_sleep=0

    while :; do
      func::getchildpids __throttle_pids
      if [ "${#__throttle_pids[*]}" -lt "${__throttle_limit}" ]; then
        break
      fi
      if (( __throttle_sleep += 1, __throttle_sleep < 10 )); then
        sleep "0.${__throttle_sleep}"
      else
        sleep 1
      fi
    done
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::addslashes -- Quotes a string with backslahses.
#
# Quotes string with backslashes. Single quote, double quote and backslash in
# subject are escaped.
#
# Usage:
#     void func::addslashes(string* subject)
func::addslashes() {
  func::str_replace "${1}" '\' '\\'
  func::str_replace "${1}" "'" "\\'"
  func::str_replace "${1}" '"' '\"'
}

# func::bin2hex -- Converts a binary string into hexadecimal representation.
#
# Converts binary data into hexadecimal representation.
#
# Usage:
#     void func::bin2hex(string* hexadecimal_output, string binary_input)
#     void func::bin2hex(string binary_input) > hexadecimal_output
#     void func::bin2hex() < binary_input > hexadecimal_output
func::bin2hex() {
  if [ "$#" -eq 0 ]; then
    od -An -tx1 | tr -d ' \n'
    return
  elif [ "$#" -eq 1 ]; then
    func::bin2hex <<<"$1"
    return
  elif [ "$#" -ne 2 ]; then
    LOG FATAL "func::bin2hex requires two arguments, but $# arguments."
    return 1
  fi
  local __bin2hex_destination="$1"
  local __bin2hex_data="$2"

  eval "${__bin2hex_destination}=\"\$(sub::print \"${__bin2hex_data}\" | func::bin2hex)\""
}

# escapeshellarg -- Escapes a variable as a shell argument.
#
# escapeshellarg escapes variable's content so as to use it as a shell argument.
#
# Usage:
#     void func::escapeshellarg(string* variable)
func::escapeshellarg() {
  local __escapeshellarg_variable="$1"
  local __escapeshellarg_search="'"
  local __escapeshellarg_replace="'\\''"

  eval "${__escapeshellarg_variable}=\"'\${${__escapeshellarg_variable}//\${__escapeshellarg_search}/\${__escapeshellarg_replace}}'\""
}

# func::explode -- Splits a string by a substring.
#
# Splits a string by string.
#
# Usage:
#     void func::explode(string* variable, string delimiter, string value)
func::explode() {
  local __explode_variable="${1}"
  local __explode_delimiter="${2}"
  local __explode_value="${3}"
  local __explode_result=()

  if [ "${__explode_delimiter}" != $'\x02' ]; then
    func::str_replace __explode_value "${__explode_delimiter}" $'\x02'
  fi
  while IFS='' read -r -d $'\x02' __explode_term; do
    __explode_result+=("${__explode_term}")
  done <<<"${__explode_value}"$'\x02'
  eval "${__explode_variable}=(\"\${__explode_result[@]}\")"
}

# func::hex2bin -- Decodes a hexadecimally encoded binary string.
#
# Decodes a hexadecimally encoded binary string.
#
# Usage:
#     void func::hex2bin(string* output, string input)
#     void func::hex2bin(string* variable)
#     void func::hex2bin() < input > output
func::hex2bin() {
  if [ "$#" -eq 0 ]; then
    local __hex2bin_variable=''
    __func::hex2bin
  elif [ "$#" -eq 2 ]; then
    local __hex2bin_variable="$1" __hex2bin_data="$2" __hex2bin_result=''
    __func::hex2bin <<<"${__hex2bin_data}"
    func::let "${__hex2bin_variable}" "${__hex2bin_result}"
  elif [ "$#" -eq 1 ]; then
    local __hex2bin_variable="$1" __hex2bin_result=''
    eval "func::hex2bin \"\${__hex2bin_variable}\" \"\${${__hex2bin_variable}}\""
  fi
}

__func::hex2bin() {
  local __hex2bin_char='' __hex2bin_buffer=''
  while read -n 1 __hex2bin_char; do
    case "${__hex2bin_char}" in
      [0-9a-fA-F]) __hex2bin_buffer+="${__hex2bin_char}";;
      *) continue;;
    esac
    if [ "${#__hex2bin_buffer}" -eq 2 ]; then
      if [ "${__hex2bin_variable}" = '' ]; then
        printf "\\x${__hex2bin_buffer}"
      else
        eval "__hex2bin_result+=\$'\\x${__hex2bin_buffer}'"
      fi
      __hex2bin_buffer=''
    fi
  done
}

# func::implode -- Joins array elements with a string.
#
# func::implode joins `pieces` with `glue`.
# *Stream form* uses the IFS environment variable as an input separator and
# processes line by line.
#
# Usage:
#     // 1. Function form.
#     void func::implode(string* variable, string glue, string[]* pieces)
#     // 2. Command form.
#     void sub::implode(string glue, string[]* pieces) > result
#     // 3. Stream form.
#     void stream::implode(string glue) < input > output
#
# Aliases:
#   func::join, sub::join and stream::join are aliases of func::implode,
#   sub::implode and stream::implode respectively.
func::implode() {
  # 1. Function form.
  if [ "$#" -eq 3 ]; then
    local __implode_variable="${1}"
    local __implode_glue="${2}"
    local __implode_pieces=()
    eval "local __implode_pieces=(\"\${${3}[@]}\")"

    local __implode_size="${#__implode_pieces[@]}"
    local __implode_i=0
    local __implode_result=''
    while (( __implode_i < __implode_size )); do
      if (( __implode_i != 0 )); then
        __implode_result+="${__implode_glue}"
      fi
      __implode_result+="${__implode_pieces[${__implode_i}]}"
      (( __implode_i += 1 )) || true
    done
    func::let "${__implode_variable}" "${__implode_result}"
  elif [ "$#" -eq 2 ]; then
    LOG ERROR 'This form is deprecated.'
    sub::implode "$@"
  elif [ "$#" -eq 1 ]; then
    LOG ERROR 'This form is deprecated.'
    stream::implode "$@"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::implode() {
  if [ "$#" -eq 2 ]; then
    local __implode_output=''
    func::implode __implode_output "${1}" "${2}"
    sub::println "${__implode_output}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::implode() {
  if [ "$#" -eq 1 ]; then
    local LINE=()
    while func::readarray; do
      sub::implode "${1}" LINE
    done
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

func::join() { func::implode "$@"; }
sub::join() { sub::implode "$@"; }
stream::join() { stream::implode "$@"; }

# func::ltrim -- Strips whitespace(s) from the beginning of a string.
#
# Strips whitespace (or other characters) from the beginning of a string.
#
# Usage:
#     void func::ltrim(string* variable)
func::ltrim() {
  if [ "$#" -eq 1 ]; then
    local __ltrim_variable="$1"
    eval "${__ltrim_variable}=\"\${${__ltrim_variable}#\"\${${__ltrim_variable}%%[![:space:]]*}\"}\""
  elif [ "$#" -eq 2 ]; then
    local __ltrim_output="$1"
    local __ltrim_input="$2"
    func::let "${__ltrim_output}" "${__ltrim_input}"
    func::ltrim "${__ltrim_output}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::md5 -- Calculates a MD5 hash.
#
# Usage:
#     void func::md5() < input > hash
#     void func::md5(string data) > hash
#     void func::md5(string* variable, string data)
func::md5() {
  if [ "$#" -eq 0 ]; then
    openssl md5 -binary | func::bin2hex
  elif [ "$#" -eq 1 ]; then
    sub::print "${1}" | func::md5
  elif [ "$#" -eq 2 ]; then
    local __md5_variable="$1"
    local __md5_data="$2"
    eval "${__md5_variable}=\"\$(func::md5 \"\${__md5_data}\")\""
  fi
}

# func::ord -- Gets a character's ASCII code.
#
# Sets ASCII value of character to variable.
#
# Usage:
#     func::ord(string* variable, string character)
func::ord() {
  local __ord_variable="$1"
  local __ord_character="$2"
  local __ord_result="$(printf '%d' \'"${__ord_character}")"
  eval "${__ord_variable}=\"\${__ord_result}\""
}

# print -- Prints a message.
#
# Print message to the standard output.  While "echo" consumes flags,
# print does not consume any flags, so this is theoretically safe.
#
# Usage:
#     // DEPRECATED
#     void func::print(string message...) > output
#     // 1. Command form.
#     void sub::print(string message...) > output
func::print() {
  printf "%s" "$*"
}

sub::print() {
  IFS=' ' eval 'printf "%s" "$*"'
}
# println -- Prints a message with a new line.
#
# Print message to the standard output with a new line.  While "echo" consumes
# flags, println does not consume any flags, so this is theoretically safe.
#
# Usage:
#     // DEPRECATED.
#     void func::println(string message...) > output
#     // 1. Command form.
#     void sub::println(string message...) > output
func::println() {
  printf "%s\n" "$*"
}

sub::println() {
  IFS=' ' eval 'printf "%s\n" "$*"'
}

# func::rtrim -- Strips whitespace(s) from the end of a string.
#
# Strips whitespace (or other characters) from the end of a string.
#
# Usage:
#     // 1. Function form.
#     void func::rtrim(string* output, string input)
#     // 2. Inplace form.
#     void func::rtrim(string* variable)
#     // 3. Command form.
#     void sub::rtrim(string value) > output
#     // 4. Stream form.
#     void stream::rtrim() < input > output
func::rtrim() {
  if [ "$#" -eq 1 ]; then
    local __rtrim_variable="$1"
    eval "${__rtrim_variable}=\"\${${__rtrim_variable}%\"\${${__rtrim_variable}##*[![:space:]]}\"}\""
  elif [ "$#" -eq 2 ]; then
    local __rtrim_output="$1"
    local __rtrim_input="$2"
    func::let "${__rtrim_output}" "${__rtrim_input}"
    func::rtrim "${__rtrim_output}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

sub::rtrim() {
  if [ "$#" -eq 1 ]; then
    local __rtrim_value="$1"
    func::rtrim __rtrim_value
    sub::println "${__rtrim_value}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

stream::rtrim() {
  if [ "$#" -eq 0 ]; then
    local LINE='' NEWLINE=''
    while func::readline; do
      func::rtrim LINE
      sub::print "${LINE}${NEWLINE}"
    done
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::str_replace -- Replaces a substring with another substring.
#
# Replace search with replace in *subject.
#
# Usage:
#     void func::str_replace(string* subject, string search, string replace)
func::str_replace() {
  if [ "$#" -ne 3 ]; then
    LOG FATAL 'func::str_replace takes exactly 3 arguments.'
  fi
  local __str_replace_subject_variable="${1}"
  local __str_replace_search="${2}"
  local __str_replace_replace="${3}"

  eval "${__str_replace_subject_variable}=\"\${${__str_replace_subject_variable}//\"\${__str_replace_search}\"/\${__str_replace_replace}}\""
}

# func::strcpy -- Copies a string from a variable to another variable.
#
# Assigns the content of a variable specified as source into destination.
#
# Usage:
#     void func::strcpy(string* destination, string *source)
func::strcpy() {
  local __strcpy_destination="$1"
  local __strcpy_source="$2"

  eval "${__strcpy_destination}=\"\${${__strcpy_source}}\""
}

# strtolower -- Makes a string lowercase.
#
# strtolower makes a string lowercase.
#
# Usage:
#     // 1. Function form.
#     void func::strtolower(string* variable)
#     // 2. Subroutine form.
#     void sub::strtolower(string input) > output
#     // 3. Stream form.
#     void stream::strtolower() < input > output
func::strtolower() {
  if [ "$#" -eq 1 ]; then
    local __strtolower_variable="$1"
    local __strtolower_value=''
    func::strcpy __strtolower_value "${__strtolower_variable}"
    # This is faster than tr for short strings.
    # TODO(imos): Use ${variable,,} instead once Mac OSX supports BASH 4.
    __strtolower_value="${__strtolower_value//A/a}"
    __strtolower_value="${__strtolower_value//B/b}"
    __strtolower_value="${__strtolower_value//C/c}"
    __strtolower_value="${__strtolower_value//D/d}"
    __strtolower_value="${__strtolower_value//E/e}"
    __strtolower_value="${__strtolower_value//F/f}"
    __strtolower_value="${__strtolower_value//G/g}"
    __strtolower_value="${__strtolower_value//H/h}"
    __strtolower_value="${__strtolower_value//I/i}"
    __strtolower_value="${__strtolower_value//J/j}"
    __strtolower_value="${__strtolower_value//K/k}"
    __strtolower_value="${__strtolower_value//L/l}"
    __strtolower_value="${__strtolower_value//M/m}"
    __strtolower_value="${__strtolower_value//N/n}"
    __strtolower_value="${__strtolower_value//O/o}"
    __strtolower_value="${__strtolower_value//P/p}"
    __strtolower_value="${__strtolower_value//Q/q}"
    __strtolower_value="${__strtolower_value//R/r}"
    __strtolower_value="${__strtolower_value//S/s}"
    __strtolower_value="${__strtolower_value//T/t}"
    __strtolower_value="${__strtolower_value//U/u}"
    __strtolower_value="${__strtolower_value//V/v}"
    __strtolower_value="${__strtolower_value//W/w}"
    __strtolower_value="${__strtolower_value//X/x}"
    __strtolower_value="${__strtolower_value//Y/y}"
    __strtolower_value="${__strtolower_value//Z/z}"
    func::let "${__strtolower_variable}" "${__strtolower_value}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

sub::strtolower() {
  if [ "$#" -eq 1 ]; then
    local value="$1"
    func::strtolower value
    sub::println "${value}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

stream::strtolower() {
  if [ "$#" -eq 0 ]; then
    tr '[A-Z]' '[a-z]'
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# strtoupper -- Makes a string uppercase.
#
# strtoupper makes a string uppercase.
#
# Usage:
#     // 1. Function form.
#     void func::strtoupper(string* variable)
#     // 2. Subroutine form.
#     void sub::strtoupper(string input) > output
#     // 3. Stream form.
#     void stream::strtoupper() < input > output
func::strtoupper() {
  if [ "$#" -eq 1 ]; then
    local __strtoupper_variable="$1"
    func::strcpy __strtoupper_value "${__strtoupper_variable}"
    # This is faster than tr for short strings.
    # TODO(imos): Use ${variable^^} instead once Mac OSX supports BASH 4.
    __strtoupper_value="${__strtoupper_value//a/A}"
    __strtoupper_value="${__strtoupper_value//b/B}"
    __strtoupper_value="${__strtoupper_value//c/C}"
    __strtoupper_value="${__strtoupper_value//d/D}"
    __strtoupper_value="${__strtoupper_value//e/E}"
    __strtoupper_value="${__strtoupper_value//f/F}"
    __strtoupper_value="${__strtoupper_value//g/G}"
    __strtoupper_value="${__strtoupper_value//h/H}"
    __strtoupper_value="${__strtoupper_value//i/I}"
    __strtoupper_value="${__strtoupper_value//j/J}"
    __strtoupper_value="${__strtoupper_value//k/K}"
    __strtoupper_value="${__strtoupper_value//l/L}"
    __strtoupper_value="${__strtoupper_value//m/M}"
    __strtoupper_value="${__strtoupper_value//n/N}"
    __strtoupper_value="${__strtoupper_value//o/O}"
    __strtoupper_value="${__strtoupper_value//p/P}"
    __strtoupper_value="${__strtoupper_value//q/Q}"
    __strtoupper_value="${__strtoupper_value//r/R}"
    __strtoupper_value="${__strtoupper_value//s/S}"
    __strtoupper_value="${__strtoupper_value//t/T}"
    __strtoupper_value="${__strtoupper_value//u/U}"
    __strtoupper_value="${__strtoupper_value//v/V}"
    __strtoupper_value="${__strtoupper_value//w/W}"
    __strtoupper_value="${__strtoupper_value//x/X}"
    __strtoupper_value="${__strtoupper_value//y/Y}"
    __strtoupper_value="${__strtoupper_value//z/Z}"
    func::let "${__strtoupper_variable}" "${__strtoupper_value}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

sub::strtoupper() {
  if [ "$#" -eq 1 ]; then
    local value="$1"
    func::strtoupper value
    sub::println "${value}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

stream::strtoupper() {
  if [ "$#" -eq 0 ]; then
    tr '[a-z]' '[A-Z]'
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::trim -- Strips whitespaces from both sides.
#
# trim strips whitespaces (or other characters) from the beginning and end of a
# string.
#
# Usage:
#     // 1. Function format.
#     void func::trim(string* output, string input)
#     // 2. Inplace format.
#     void func::trim(string* variable)
func::trim() {
  if [ "$#" -eq 1 ]; then
    local __trim_variable="$1"
    func::rtrim "${__trim_variable}"
    func::ltrim "${__trim_variable}"
  elif [ "$#" -eq 2 ]; then
    local __trim_output="$1"
    local __trim_input="$2"
    func::let "${__trim_output}" "${__trim_input}"
    func::trim "${__trim_output}"
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

# func::boolval -- Casts a variable as a boolean value.
#
# Casts variable as a boolean value.  If it fails, returns 1.
#
# Usage:
#     bool func::boolval(string* variable)
func::boolval() {
  local __boolval_variable="$1"
  eval "local __boolval_value=\"\${${__boolval_variable}}\""

  func::trim __boolval_value
  if [ "${__boolval_value}" = '' ]; then
    __boolval_value=0
  elif [[ "${__boolval_value}" =~ ^T|t|[Tt]rue$ ]]; then
    __boolval_value=1
  elif [[ "${__boolval_value}" =~ ^F|f|[Ff]alse$ ]]; then
    __boolval_value=0
  elif func::intval __boolval_value; then
    if (( __boolval_value )); then
      __boolval_value=1
    fi
  else
    func::let "${__boolval_variable}" 0
    return 1
  fi
  func::let "${__boolval_variable}" "${__boolval_value}"
}

# func::cast -- Casts a variable.
#
# Casts variable into a specified type.
#
# Usage:
#     bool func::cast(variant* variable, string type)
func::cast() {
  local __cast_variable="${1}"
  local __cast_type="${2}"

  case "${__cast_type}" in
    multi*)
      local __cast_values=()
      local __cast_element_type="${__cast_type:5}"
      func::array_values __cast_values "${__cast_variable}"
      if [ "${#__cast_values[*]}" -ne 0 ]; then
        local __cast_index=0
        for __cast_index in "${!__cast_values[@]}"; do
          local __cast_value="${__cast_values[${__cast_index}]}"
          if ! func::cast __cast_value "${__cast_element_type}"; then
            return 1
          fi
          __cast_values["${__cast_index}"]="${__cast_value}"
        done
      fi
      func::array_values "${__cast_variable}" __cast_values
      ;;
    int)     if ! func::intval "${__cast_variable}"; then return 1; fi;;
    float)   if ! func::floatval "${__cast_variable}"; then return 1; fi;;
    string)  if ! func::strval "${__cast_variable}"; then return 1; fi;;
    bool)    if ! func::boolval "${__cast_variable}"; then return 1; fi;;
    variant) return 0;;
    *)       LOG FATAL "Unknown type: ${__cast_type}";;
  esac
}

func::cast_or_die() {
  if ! func::cast "${@}"; then
    IFS=' ' eval 'LOG FATAL "Type mismatch: ${*}"'
  fi
}

# func::floatval -- Casts a variable as a float value.
#
# Casts variable into float type.  If it fails, returns 1.
#
# Usage:
#     bool func::floatval(string* variable)
func::floatval() {
  local __floatval_variable="$1"

  local __floatval_value
  eval "__floatval_value=\"\${${__floatval_variable}}\""
  if [[ "${__floatval_value}" =~ ^[[:space:]]*(-?[0-9]+(\.[0-9]+)?) ]]; then
    func::let "${__floatval_variable}" "${BASH_REMATCH[1]}"
  else
    return 1
  fi
}

# func::intval -- Casts a variable as an integer value.
#
# Casts variable into integer type.  If it fails, returns 1.
#
# Usage:
#     bool func::intval(string* variable)
func::intval() {
  local __intval_variable="$1"

  local __intval_value
  eval "__intval_value=\"\${${__intval_variable}}\""
  if [[ "${__intval_value}" =~ ^[[:space:]]*(-?[0-9]+) ]]; then
    func::let "${__intval_variable}" "${BASH_REMATCH[1]}"
  else
    return 1
  fi
}

# func::isset -- Checks if a variable exists.
#
# Returns true iff variable exists.
#
# Usage:
#     bool func::isset(variant* variable)
#
# CAVEATS:
#   func::isset returns true for uninitialized variables in BASH 3, and returns
#   false for them in BASH 4.
func::isset() {
  local __isset_variable="$1"

  eval "local __isset_state=\"\${${__isset_variable}+set}\""
  if [ "${__isset_state}" = 'set' ]; then
    return 0
  fi
  return 1
}

# func::let -- Assigns a value into a variable.
#
# Assigns value into *destination.
#
# Usage:
#     func::let(string* destination, string value)
func::let() {
  local __let_destination="$1"
  local __let_value="$2"

  eval "${__let_destination}=\"\${__let_value}\""
}

# func::strval -- Casts a variable as a string value.
#
# Casts variable into string type.
#
# Usage:
#     void func::strval(string* variable)
func::strval() {
  local __strval_variable="$1"

  eval "${__strval_variable}=\"\${${__strval_variable}}\""
}

CHECK() {
  IFS=' ' eval 'local __CHECK_message="Check failure: $*"'
  if [ "$#" -ge 1 ] && [ "${1:0:10}" = '--message=' ]; then
    __CHECK_message="${1:10}"
    shift
  fi

  if [ "$#" -ge 1 ]; then
    local __CHECK_invert="$1"

    if [ "${__CHECK_invert}" = '!' ]; then
      shift
      if "$@"; then
        IFS=' ' eval 'LOG ERROR "Check failure: ! $*"'
        LOG FATAL "${__CHECK_message}"
      fi
    else
      if ! "$@"; then
        IFS=' ' eval 'LOG ERROR "Check failure: $*"'
        LOG FATAL "${__CHECK_message}"
      fi
    fi
  else
    LOG ERROR "Wrong number of arguments: $#"
    return 1
  fi
}

imosh::internal::loglevel() {
  case "$1" in
    ALL)     echo 0;;
    INFO)    echo 1;;
    WARNING) echo 2;;
    ERROR)   echo 3;;
    FATAL)   echo 4;;
    NONE)    echo 5;;
    *)       LOG FATAL "unknown level: $1";;
  esac
}

LOG() {
  local level="$1"
  shift

  case "${level}" in
    INFO|WARNING|ERROR|FATAL) :;;
    *) LOG FATAL "no such log level: ${level}"
  esac
  local datetime="$(date +'%m%d %T.%N')"
  # For systems not supporting %N in date.
  datetime="${datetime/.N/.000000}"
  datetime="${datetime:0:20}"
  local pid
  if func::isset __IMOSH_LOG_PID; then
    pid="${__IMOSH_LOG_PID}"
  else
    func::getmypid pid
  fi
  local file="${BASH_SOURCE[1]##*/}"
  if [ "${file}" = '' ]; then file='-'; fi
  local message=(
      "${level:0:1}${datetime}"
      "${pid}"
      "${file}:${BASH_LINENO[0]}]"
      "$@")
  IFS=' ' eval 'message="${message[*]}"'
  if ! func::isset FLAGS_stacktrace_threshold || \
     [ "${FLAGS_stacktrace_threshold}" = '' ]; then
    FLAGS_stacktrace_threshold='ERROR'
  fi
  if [ "$(imosh::internal::loglevel "${level}")" -ge \
       "$(imosh::internal::loglevel "${FLAGS_stacktrace_threshold}")" ]; then
    message+=$'\n'
    message+="$(imosh::stack_trace "*** LOG ${level} stack trace: ***" 2>&1)"
  fi
  local logtostderr=0
  if func::isset FLAGS_logtostderr; then
    logtostderr="${FLAGS_logtostderr}"
  fi
  local alsologtostderr=0
  if func::isset FLAGS_alsologtostderr; then
    alsologtostderr="${FLAGS_alsologtostderr}"
  fi
  case "${level}" in
    INFO)
      if (( logtostderr || alsologtostderr )); then
        echo "${message}" >&105
      fi
      if (( ! logtostderr )); then
        echo "${message}" >&101
      fi
      ;;
    WARNING)
      if (( logtostderr || alsologtostderr )); then
        echo "${message}" >&105
      fi
      if (( ! logtostderr )); then
        echo "${message}" >&101
        echo "${message}" >&102
      fi
      ;;
    ERROR)
      echo "${message}" >&105
      if (( ! logtostderr )); then
        echo "${message}" >&101
        echo "${message}" >&102
        echo "${message}" >&103
      fi
      ;;
    FATAL)
      echo "${message}" >&105
      if (( ! logtostderr )); then
        echo "${message}" >&101
        echo "${message}" >&102
        echo "${message}" >&103
        echo "${message}" >&104
      fi
      func::exit 1
      ;;
  esac
}

imosh::internal::log_file() {
  local severity="${1}"
  local path=''
  if [ "${FLAGS_log_dir}" == '' ]; then
    return
  fi
  path+="${FLAGS_log_dir}/"
  path+="${__IMOSH_LOG_PREFIX}.${severity}.${__IMOSH_LOG_SUFFIX}"
  sub::print "${path}"
}

imosh::internal::init_log() {
  # Close descriptors for logs beforehand for BASH3's bug.
  exec 101>&- 102>&- 103>&- 104>&-
  if [ "${FLAGS_log_dir}" != '' -a -w "${FLAGS_log_dir}" ]; then
    exec 101>"$(imosh::internal::log_file INFO)"
    exec 102>"$(imosh::internal::log_file WARNING)"
    exec 103>"$(imosh::internal::log_file ERROR)"
    exec 104>"$(imosh::internal::log_file FATAL)"
    return
  fi
  exec 101>/dev/null 102>/dev/null 103>/dev/null 104>/dev/null
  if [ "${FLAGS_log_dir}" == '' ]; then
    return
  fi
  LOG ERROR "failed to open files to write logs: ${__IMOSH_LOG_DIR}"
}

# Parses arguments without getopt.
imosh::internal::parse_args() {
  local class_name="$1"; shift

  local upper_class_name="${class_name}"
  func::strtoupper upper_class_name
  local arg arg_name arg_value
  IMOSH_ARGV=()
  IMOSH_ARGS=()
  while [ "$#" != '0' ]; do
    local arg="$1"
    shift
    if [ "${arg:0:1}" != '-' ]; then
      IMOSH_ARGV+=("${arg}")
      continue
    fi
    if [[ "${arg}" =~ ^-[0-9] ]]; then
      IMOSH_ARGV+=("${arg}")
      continue
    fi
    if [ "${arg}" = '--' ]; then
      IMOSH_ARGV+=("$@")
      break
    fi
    case "${arg}" in
      --*) arg="${arg:2}";;
      -*) arg="${arg:1}";;
    esac
    arg_name="${arg%%=*}"
    if [[ ! "${arg_name}" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
      LOG FATAL "${class_name} name is bad: ${arg_name}"
    fi
    arg_value="${arg:${#arg_name}}"
    if [ "${arg_value:0:1}" != '=' ]; then
      if [ "${arg_name:0:2}" = 'no' ]; then
        if func::isset "${upper_class_name}S_${arg_name:2}"; then
          if [ "${class_name}" != 'flag' ] || \
             [ "$(imosh::internal::flag_type "${arg_name:2}")" = 'bool' ]; then
            IMOSH_ARGS+=("${upper_class_name}S_${arg_name:2}=0")
            continue
          fi
        fi
      fi
      if func::isset "${upper_class_name}S_${arg_name}"; then
        if [ "${class_name}" != 'flag' ] ||
           [ "$(imosh::internal::flag_type "${arg_name}")" = 'bool' ]; then
          IMOSH_ARGS+=("${upper_class_name}S_${arg_name}=1")
          continue
        fi
      fi
      if ! func::isset "${upper_class_name}S_${arg_name}"; then
        LOG FATAL "no such bool ${class_name} is defined:" \
                  "(${upper_class_name}S_)${arg_name}"
      fi
      if [ "$#" -eq 0 ]; then
        LOG FATAL "the ${arg_name} flag requires a value"
      fi
      arg_value="=${1}"
      shift
    fi
    arg_value="${arg_value:1}"
    if func::isset "${upper_class_name}S_${arg_name}"; then
      if [ "${class_name}" = 'flag' ]; then
        local original_value="${arg_value}"
        local type="$(imosh::internal::flag_type "${arg_name}")"
        if [ "${type:0:5}" = 'multi' ]; then
          # TODO(imos): Support delimiter.
          func::explode arg_value ',' "${arg_value}"
        fi
        CHECK \
            --message="${upper_class_name}S_${arg_name} is invalid: ${arg_value}" \
            func::cast arg_value "$(imosh::internal::flag_type "${arg_name}")"
        if [ "${type:0:5}" = 'multi' ]; then
          # Set values here.  FLAGS_* are global variables, and this does not
          # cause scope issues.
          func::array_values "${upper_class_name}S_${arg_name}" arg_value
        else
          IMOSH_ARGS+=("${upper_class_name}S_${arg_name}=${arg_value}")
        fi
      else
        IMOSH_ARGS+=("${upper_class_name}S_${arg_name}=${arg_value}")
      fi
      continue
    fi
    LOG FATAL "no such ${class_name} is defined:" \
              "(${upper_class_name}S_)${arg_name}"
  done
}

# imosh::exit
#
# Usage:
#   void imosh::exit(int status = 0)
#
# imosh::exit kills all the subprocesses of the root process with the status.
imosh::exit() {
  if [ "$#" -eq 0 ]; then
    set -- 0
  fi
  if [ "$#" -eq 1 ]; then
    local status="$1"
    echo "${status}" >"${__IMOSH_CORE_TMPDIR}/status"

    local PID=''
    func::getmypid PID
    # First, kill all the childs of the current process so that no child
    # processes spawn new processes.
    __imosh::kill "${PID}"
    # Then, try to kill other processes under the root process except this
    # process.
    __imosh::kill "${IMOSH_ROOT_PID}"
    # Send a TERM signal to the root process.
    kill -TERM "${IMOSH_ROOT_PID}" 2>/dev/null || true
    # Exit immediately.
    exit "${status}"
  else
    LOG FATAL "Wrong number of aruments: $#"
  fi
}

# __imosh::kill
#
# Usage:
#   void __imosh::kill(int pid)
#
# __imosh::kill must not be called by functions other than imosh::exit because
# a killer process `PID` must not be stopped by a signal.
__imosh::kill() {
  if [ "$#" -eq 1 ]; then
    local target_pid="$1"
    LOG INFO "killing ${target_pid}..."
    local keep_alive=0
    if [ "${target_pid}" = "${PID}" -o \
         "${target_pid}" = "${IMOSH_ROOT_PID}" ]; then
      keep_alive=1
    fi
    if (( ! keep_alive )); then
      kill -STOP "${target_pid}" 2>/dev/null || true
    fi
    export IFS=$' \t\n'
    local child_pids="$(ps -o ppid,pid | \
                        grep "^[[:space:]]*${target_pid}[[:space:]]" | \
                        awk '{ print $2 }')"
    if [ "${child_pids}" != '' ]; then
      LOG INFO "Target PID (${target_pid})'s child PIDs are: ${child_pids[*]}"
      local child=''
      for child in ${child_pids}; do
        __imosh::kill "${child}"
      done
    else
      LOG INFO "Target PID (${target_pid}) has no child PIDs."
    fi
    if (( ! keep_alive )); then
      kill -KILL "${target_pid}" 2>/dev/null || true
    fi
  else
    LOG FATAL "Wrong number of arguments: $#"
  fi
}

# __IMOSH_FLAGS_TYPE_<flag name>=<flag type>
# __IMOSH_FLAGS_DESCRIPTION_<flag name>=<description>
# __IMOSH_FLAGS_ALIASES=(from:to ...)

imosh::internal::flag_type() {
  local name="$1"

  if [ "$#" -ne 1 ]; then
    LOG FATAL 'flag_type requires 1 arugument.'
  fi
  eval "sub::print \"\${__IMOSH_FLAGS_TYPE_${name}}\""
}

imosh::internal::define_flag() {
  local type="$1"; shift

  local ARGS_alias='' ARGS_alias_flag=0 ARGS_group='main'
  eval "${IMOSH_PARSE_ARGUMENTS}"

  if [ "$#" -lt 3 ]; then
    LOG FATAL 'DEFINE_${type} requires 3+ arguments.'
  fi
  local name="$1"; shift
  local default_value="$1"; shift
  local original_default_value="${default_value}"
  local description="$*"
  local group="${ARGS_group}"
  func::strtoupper group

  # Change the default value based on its corresponding environment variable.
  if func::isset "IMOSH_FLAGS_${name}"; then
    func::strcpy default_value "IMOSH_FLAGS_${name}"
  fi
  if [ "${type:0:5}" = 'multi' ]; then
    func::explode default_value ',' "${default_value}"
  fi
  CHECK \
      --message="${name}'s default value is invalid: ${original_default_value}." \
      func::cast default_value "${type}"
  if func::isset "__IMOSH_FLAGS_TYPE_${name}"; then
    LOG FATAL "already defined flag: ${name}"
  fi
  if [ "${type:0:5}" = 'multi' ]; then
    func::array_values "FLAGS_${name}" 'default_value'
  else
    func::strcpy "FLAGS_${name}" 'default_value'
  fi
  func::strcpy "__IMOSH_FLAGS_TYPE_${name}" 'type'
  if [ "${ARGS_alias}" != '' ]; then
    imosh::internal::define_flag "${type}" --alias_flag \
        "${ARGS_alias}" "${original_default_value}" "${description}"
    __IMOSH_FLAGS_ALIASES+=("${name}:${ARGS_alias}")
  fi
  if (( ! ARGS_alias_flag )); then
    local escaped_default_value=''
    case "${type}" in
      int) escaped_default_value="${default_value}";;
      bool)
        if (( default_value )); then
          escaped_default_value='true'
        else
          escaped_default_value='false'
        fi
        ;;
      *)
        escaped_default_value="${original_default_value}"
        func::escapeshellarg escaped_default_value
        ;;
    esac
    func::let "__IMOSH_FLAGS_DEFAULT_${name}" \
              "--${name}=${escaped_default_value}"
    if [ "${ARGS_alias}" != '' ]; then
      description+=" (Alias: --${ARGS_alias})"
    fi
    func::let "__IMOSH_FLAGS_DESCRIPTION_${name}" "${description}"
    __IMOSH_FLAGS+=("${group}:${name}")
  fi
}

DEFINE_string() { imosh::internal::define_flag string "$@"; }
DEFINE_int() { imosh::internal::define_flag int "$@"; }
DEFINE_bool() { imosh::internal::define_flag bool "$@"; }
DEFINE_double() { imosh::internal::define_flag double "$@"; }
DEFINE_multistring() { imosh::internal::define_flag multistring "$@"; }
DEFINE_multiint() { imosh::internal::define_flag multiint "$@"; }
DEFINE_multibool() { imosh::internal::define_flag multibool "$@"; }
DEFINE_multidouble() { imosh::internal::define_flag multidouble "$@"; }
DEFINE_list() { DEFINE_multistring "${@}"; }

imosh::internal::get_main_script() {
  local depth="${#BASH_SOURCE[@]}"
  local main_script="${BASH_SOURCE[$((depth-1))]}"
  echo "${main_script}"
}

imosh::internal::get_usage() {
  local file="${1}"
  while IFS='' read -r line; do
    case "${line}" in
      '#!'*) continue;;
      '# '*) echo "${line:2}";;
      '#'*)  echo "${line:1}";;
      *)     break;;
    esac
  done < "${file}" > "${__IMOSH_CORE_TMPDIR}/usage"
  if [ -s "${__IMOSH_CORE_TMPDIR}/usage" ]; then
    cat "${__IMOSH_CORE_TMPDIR}/usage"
  else
    echo 'No description.'
  fi
}

imosh::internal::flag_groups() {
  local groups=()
  local group=''
  local main_group_exists=0
  local imosh_group_exists=0
  for flag_name in "${__IMOSH_FLAGS[@]}"; do
    local parts=()
    func::explode parts ':' "${flag_name}"
    group="${parts[0]}"
    local lower_group="${group}"
    func::strtolower lower_group
    if [ "${lower_group}" == 'main' ]; then
      main_group_exists=1
    elif [ "${lower_group}" == 'imosh' ]; then
      imosh_group_exists=1
    else
      groups+=("${group}")
    fi
  done
  if (( main_group_exists )); then
    echo 'main'
  fi
  if [ "${#groups[@]}" -ne 0 -a "${FLAGS_helpfull}" -ne 0 ]; then
    func::array_unique groups
    for group in "${groups[@]}"; do
      echo "${group}"
    done
  fi
  if (( imosh_group_exists && FLAGS_helpfull )); then
    echo 'imosh'
  fi
}

imosh::internal::group_flags() {
  local group="$1"
  local lower_group="${group}"
  func::strtolower lower_group

  local flags=()
  for flag_name in "${__IMOSH_FLAGS[@]}"; do
    local parts=()
    func::explode parts ':' "${flag_name}"
    local lower_part="${parts[0]}"
    func::strtolower lower_part
    if [ "${lower_group}" != "${lower_part}" ]; then
      continue
    fi
    flags+=("${parts[1]}")
  done
  func::sort flags
  for flag in "${flags[@]}"; do
    echo "${flag}"
  done
}

imosh::internal::man() {
  echo ".TH ${0##*/} 1"; echo
  echo '.SH DESCRIPTION'
  __imosh::show_usage --format=groff --notitle \
      "$(imosh::internal::get_main_script)"

  echo '.SH OPTIONS'
  for flag_group in $(imosh::internal::flag_groups); do
    local upper_flag_group="${flag_group}"
    func::strtoupper upper_flag_group
    echo ".SS ${upper_flag_group} OPTIONS"
    for flag_name in $(imosh::internal::group_flags "${flag_group}"); do
      echo '.TP'
      echo -n '\fB'
      eval "echo -n \"\${__IMOSH_FLAGS_DEFAULT_${flag_name}}\""
      echo '\fP'
      eval "echo \"\${__IMOSH_FLAGS_DESCRIPTION_${flag_name}}\""
      echo
    done
  done
}

imosh::internal::help() {
  __imosh::show_usage --format=text --notitle \
      "$(imosh::internal::get_main_script)"
  echo "OPTIONS:"
  for flag_group in $(imosh::internal::flag_groups); do
    local upper_flag_group="${flag_group}"
    func::strtoupper upper_flag_group
    echo "  ${upper_flag_group} OPTIONS:"
    for flag_name in $(imosh::internal::group_flags "${flag_group}"); do
      eval "echo \"    \${__IMOSH_FLAGS_DEFAULT_${flag_name}}\""
      eval "echo \"\${__IMOSH_FLAGS_DESCRIPTION_${flag_name}}\"" | \
          fold -s -w 70 | while IFS= read -r line; do
        sub::println "        ${line}"
      done
    done
  done
}

__imosh::help_markdown() {
  __imosh::show_usage --format=markdown --notitle \
      "$(imosh::internal::get_main_script)"
  echo "# Options"
  for flag_group in $(imosh::internal::flag_groups); do
    local upper_flag_group="${flag_group}"
    func::strtoupper upper_flag_group
    echo "## ${flag_group} options"
    for flag_name in $(imosh::internal::group_flags "${flag_group}"); do
      eval "echo \"* \${__IMOSH_FLAGS_DEFAULT_${flag_name}}\""
      eval "echo \"    * \${__IMOSH_FLAGS_DESCRIPTION_${flag_name}}\""
    done
  done
}

__imosh::help() {
  case "${FLAGS_help_format}" in
    groff)
      imosh::internal::man;;
    markdown)
      __imosh::help_markdown;;
    *)
      imosh::internal::help;;
  esac
}

imosh::internal::init() {
  imosh::internal::parse_args flag "$@"
  if [ "${#IMOSH_ARGS[@]}" -ne 0 ]; then
    eval "${IMOSH_ARGS[@]}"
  fi
  imosh::internal::init_log
  if [ "${#__IMOSH_FLAGS_ALIASES[@]}" -ne 0 ]; then
    for alias in "${__IMOSH_FLAGS_ALIASES[@]}"; do
      eval "FLAGS_${alias%%:*}=\"\${FLAGS_${alias#*:}}\""
      unset "FLAGS_${alias#*:}"
    done
  fi
  if [ "${#IMOSH_ARGS[@]}" -ne 0 ]; then
    eval "${IMOSH_ARGS[@]}"
  fi
  if (( FLAGS_help || FLAGS_helpfull )) ||
     [ "${FLAGS_help_format}" != '' ]; then
    if [ "${FLAGS_help_format}" = '' ]; then
      if [ -t 1 ]; then
        FLAGS_help_format='groff'
      else
        FLAGS_help_format='text'
      fi
    fi
    if [ -t 1 -a "${FLAGS_help_format}" = 'groff' ]; then
      local man_file="${__IMOSH_CORE_TMPDIR}/man"
      __imosh::help >"${man_file}"
      man "${man_file}"
    else
      __imosh::help >&2
    fi
    exit 0
  fi
}

# Usage:
#   imosh::stack_trace [--skip_imosh] [message...]
#
# Shows a stack trace.  Arguments are used as a message.
imosh::stack_trace() {
  local ARGS_skip_imosh=0
  eval "${IMOSH_PARSE_ARGUMENTS}"

  local max_depth="${#BASH_LINENO[@]}"
  local i=0
  if [ "$*" = '' ]; then
    echo 'imosh::stack_trace is called' >&2
  else
    echo "$*" >&2
  fi
  while (( i < max_depth - 1 )); do
    if [ "${BASH_SOURCE[$((i+1))]}" != "${BASH_SOURCE[0]}" ]; then
      break
    fi
    (( i += 1 )) || true
  done
  while (( i < max_depth - 1 )); do
    local lineno="${BASH_LINENO[$((i))]}"
    local file="${BASH_SOURCE[$((i+1))]}"
    local function="${FUNCNAME[$((i+1))]}"
    echo "  at ${function} (${file}:${lineno})" >&2
    (( i += 1 )) || true
  done
}

__imosh::mktemp() {
  TMPDIR="${TMPDIR:-/tmp}"
  TMPDIR="${TMPDIR%/}"
  export TMPDIR="$(mktemp -d "${TMPDIR:-/tmp}/imosh.XXXXXX")"
  if [ "${TMPDIR}" = '' -o "${TMPDIR}" = '/' ]; then
    LOG FATAL 'failed to create a temporary directory.'
  fi

  export __IMOSH_CORE_TMPDIR="${TMPDIR}/.imosh"
  mkdir "${__IMOSH_CORE_TMPDIR}"
  local tmpdir="${TMPDIR}"
  func::escapeshellarg tmpdir
  func::atexit "rm -rf ${tmpdir}"

  # For backward compatibility.
  export IMOSH_TMPDIR="${TMPDIR}"
}

# __imosh::get_usage
#
# Usage:
#   void __imosh::get_usage(string file) > output
__imosh::get_usage() {
  local file="$1"
  local line=''
  while IFS= read -r line; do
    case "${line}" in
      '#!'*) continue;;
      '# '*) echo "${line:2}";;
      '#'*)  echo "${line:1}";;
      *)     break;;
    esac
  done < "${file}"
}

# __imosh::show_usage
#
# Usage:
#     bool __imosh::show_usage(string file) > output
#
# Options:
#   --format=text
#     Select one fromat from text/markdown/groff.
#   --title=true
#     Treat the first line as title.
#   --markdown_heading=''
#     Prepend a string to every heading.
__imosh::show_usage() {
  local ARGS_format=text ARGS_title=1 ARGS_markdown_heading=''
  eval "${IMOSH_PARSE_ARGUMENTS}"

  if [ "$#" -eq 1 ]; then
    local file="$1"

    local usage="$(__imosh::get_usage "$1")"
    if [ "${usage}" = '' ]; then
      return
    fi

    local line='' first_line="${ARGS_title}" no_read=0
    while :; do
      if (( ! no_read )) && ! IFS= read -r line; then
        break
      fi
      no_read=0
      if [ "${ARGS_format}" = 'text' ]; then
        echo "${line}"
        continue
      fi
      func::rtrim line
      if (( first_line )); then
        case "${ARGS_format}" in
          groff)    echo ".TH ${line} 1";;
          markdown) echo "${ARGS_markdown_heading} ${line}";;
        esac
        first_line=0
        continue
      fi
      if func::greg_match '*:' "${line}"; then
        local title="${line%:}"
        func::strtoupper title
        case "${ARGS_format}" in
          groff)    echo ".SH ${title}";;
          markdown) echo "${ARGS_markdown_heading}# ${line%:}";;
        esac
        continue
      fi

      local code_mode=0
      while [ "${line:0:4}" = '    ' ]; do
        if (( ! code_mode )); then
          case "${ARGS_format}" in
            groff)    echo '.Bd -literal -offset indent';;
            markdown) echo '```sh';;
          esac
          code_mode=1
        fi
        case "${ARGS_format}" in
          groff)    echo "${line#'    '}";;
          markdown) echo "${line#'    '}";;
        esac
        code_mode=1
        if ! IFS= read -r line; then break; fi
      done
      if (( code_mode )); then
        case "${ARGS_format}" in
          groff)    echo '.Ed';;
          markdown) echo '```'
                    echo;;
        esac
        no_read=1
        continue
      fi

      if func::greg_match '*( )-*' "${line}"; then
        func::ltrim line
        if [ "${line:0:2}" = '- ' ]; then
          line="${line:2}"
        fi
        case "${ARGS_format}" in
          groff)    echo '.TP'
                    echo ".B ${line}";;
          markdown) echo "* ${line}";;
        esac
        local item_first_line=1
        while IFS= read -r line; do
          if func::greg_match '*( )-*' "${line}" || \
             func::greg_match '*([[:space:]])' "${line}"; then
            break
          fi
          func::ltrim line
          case "${ARGS_format}" in
            groff)    echo "${line}";;
            markdown)
              if (( item_first_line )); then
                echo "    * ${line}"
                item_first_line=0
              else
                echo "      ${line}"
              fi
              ;;
          esac
        done
        no_read=1
        continue
      fi
      echo "${line}"
    done <<<"${usage}"
    echo
  else
    LOG FATAL "Wrong number of arguments: $#"
  fi
}

ASSERT() {
  local last_state="${IMOSH_TEST_IS_FAILED}"
  IMOSH_TEST_IS_FAILED=0
  "$@"
  if (( IMOSH_TEST_IS_FAILED )); then
    exit 1
  fi
  IMOSH_TEST_IS_FAILED="${last_state}"
}

FAILURE() {
  IMOSH_TEST_IS_FAILED=1
  imosh::stack_trace --skip_imosh '*** Check failure ***'
}

EXPECT_TRUE() {
  if ! "$@"; then
    echo '  Actual: false' >&2
    echo 'Expected: true' >&2
    FAILURE
    return 1
  fi
  IFS=' ' eval 'LOG INFO "EXPECT_TRUE passes: $*"'
}

EXPECT_FALSE() {
  if "$@"; then
    echo '  Actual: true' >&2
    echo 'Expected: false' >&2
    FAILURE
    return 1
  fi
  IFS=' ' eval 'LOG INFO "EXPECT_FALSE passes: $*"'
}

ASSERT_TRUE() {
  ASSERT EXPECT_TRUE "$@"
}

ASSERT_FALSE() {
  ASSERT EXPECT_FALSE "$@"
}

# EXPECT_DEATH, EXPECT_ALIVE, ASSERT_DEATH, ASSERT_ALIVE
#
# Usage:
#   bool EXPECT_DEATH(string arguments...)
#   bool EXPECT_ALIVE(string arguments...)
#   void ASSERT_DEATH(string arguments...)
#   void ASSERT_ALIVE(string arguments...)
EXPECT_DEATH() {
  "$@" &
  if wait "$!"; then
    IFS=' ' eval 'LOG ERROR "Command did not die unexpectedly: $*"'
    return 1
  fi
  IFS=' ' eval 'LOG INFO "Command died as expected: $*"'
}

EXPECT_ALIVE() {
  "$@" &
  if ! wait "$!"; then
    IFS=' ' eval 'LOG ERROR "Command died unexpectedly: $*"'
    return 1
  fi
  IFS=' ' eval 'LOG INFO "Command did not die as expected: $*"'
}

ASSERT_DEATH() { ASSERT EXPECT_DEATH "$@"; }
ASSERT_ALIVE() { ASSERT EXPECT_ALIVE "$@"; }

# EXPECT_EQ, ASSERT_EQ -- Check if two values are equal.
#
# Usage:
#   bool EXPECT_EQ(string expected, string actual)
#   void ASSERT_EQ(string expected, string actual)
#
# Aliases:
#   EXPECT_STREQ is an alias of EXPECT_EQ, and ASSERT_STREQ is an alias of
#   ASSERT_EQ.
EXPECT_EQ() {
  if [ "$#" -ne 2 ]; then
    LOG ERROR 'EXPECT_EQ requires two arguments.'
    return 1
  fi
  if [ "$1" != "$2" ]; then
    echo "  Actual: $2" >&2
    echo "Expected: $1" >&2
    FAILURE
    return 1
  fi
  LOG INFO "EXPECT_EQ passes: '$1' == '$2'"
}

ASSERT_EQ() {
  ASSERT EXPECT_EQ "$@"
}

EXPECT_STREQ() { EXPECT_EQ "$@"; }
ASSERT_STREQ() { ASSERT_EQ "$@"; }

# EXPECT_NE, ASSERT_NE -- Check if two values are not equal.
#
# Usage:
#   bool EXPECT_NE(string expected, string actual)
#   void ASSERT_NE(string expected, string actual)
#
# Aliases:
#   EXPECT_STRNE is an alias of EXPECT_NE, and ASSERT_STRNE is an alias of
#   ASSERT_NE.
EXPECT_NE() {
  if [ "$#" -ne 2 ]; then
    LOG ERROR 'EXPECT_NE requires two arguments.'
    return 1
  fi
  if [ "$1" = "$2" ]; then
    echo "Actual: $2" >&2
    echo "Target: $1" >&2
    FAILURE
    return 1
  fi
  LOG INFO "EXPECT_NE passes: '$1' != '$2'"
}

ASSERT_NE() {
  ASSERT EXPECT_NE "$@"
}

EXPECT_STRNE() { EXPECT_NE "$@"; }
ASSERT_STRNE() { ASSERT_NE "$@"; }

# Return if imosh is reloaded.  Operations in 50+ run level may have
# destructive operations, so they are skipped in reloading.
if [ "${__IMOSH_IS_LOADED+loaded}" = 'loaded' ]; then
  return
fi

# Color definitions.  A shell script should restore terminal's original color
# using IMOSH_STYLE_DEFAULT when it changes color or style.

readonly IMOSH_STYLE_DEFAULT=$'\033[0m'
readonly IMOSH_COLOR_DEFAULT=$'\033[0;39m'
readonly IMOSH_COLOR_BLACK=$'\033[0;30m'
readonly IMOSH_COLOR_RED=$'\033[0;31m'
readonly IMOSH_COLOR_GREEN=$'\033[0;32m'
readonly IMOSH_COLOR_YELLOW=$'\033[0;33m'
readonly IMOSH_COLOR_BLUE=$'\033[0;34m'
readonly IMOSH_COLOR_MAGENTA=$'\033[0;35m'
readonly IMOSH_COLOR_CYAN=$'\033[0;36m'
readonly IMOSH_COLOR_WHITE=$'\033[0;37m'

readonly IMOSH_PARSE_ARGUMENTS='
    local IMOSH_ARGV IMOSH_ARGS
    imosh::internal::parse_args arg "$@"
    if [ "${#IMOSH_ARGS[@]}" -ne 0 ]; then
      readonly "${IMOSH_ARGS[@]}"
    fi
    if [ "${#IMOSH_ARGV[@]}" -ne 0 ]; then
      set -- "${IMOSH_ARGV[@]}"
    else
      set --
    fi'

readonly IMOSH_WRONG_NUMBER_OF_ARGUMENTS='
    LOG ERROR "Wrong number of arguments: $#"
    return 1'

readonly IMOSH_INIT='
    set -e -u
    imosh::internal::init "$@"
    if [ "${#IMOSH_ARGV[@]}" -ne 0 ]; then
      set -- "${IMOSH_ARGV[@]}"
    else
      set --
    fi'

__IMOSH_FLAGS=()
__IMOSH_FLAGS_ALIASES=()

# Process ID that imosh initially runs on.
readonly IMOSH_ROOT_PID="$$"

# Variable not to output stack trace multiple times when exiting.
__IMOSH_STACK_TRACED=0

if ! func::isset UNAME; then
  UNAME="$(uname)"
fi

__IMOSH_PROGRAM_NAME="${0##*/}"
__IMOSH_HOSTNAME="$(hostname -s)"
__IMOSH_USER="$(whoami)"
__IMOSH_LOG_PREFIX="${__IMOSH_PROGRAM_NAME}.${__IMOSH_HOSTNAME}.${__IMOSH_USER}"
__IMOSH_LOG_SUFFIX="$(date +'%Y%m%d.%H%M%S').$$"

__imosh::error_handler() {
  local exit_code="$?"
  __IMOSH_STACK_TRACED=1
  imosh::stack_trace "error status: ${exit_code}"
}

trap '__imosh::error_handler' ERR

__imosh::exit_handler() {
  local exit_code="$?"
  if (( exit_code && ! __IMOSH_STACK_TRACED )); then
    imosh::stack_trace "error status: ${exit_code}"
  fi

  local pid=''
  func::getmypid pid
  if [ "${pid}" != "${IMOSH_ROOT_PID}" ]; then
    LOG INFO 'finalizing a child process...'
    return
  fi

  LOG INFO 'finalizing...'

  set +e
  if [ -f "${__IMOSH_CORE_TMPDIR}/atexit.sh" ]; then
    source "${__IMOSH_CORE_TMPDIR}/atexit.sh"
  fi
  rm -rf "${__IMOSH_CORE_TMPDIR}"

  # Close log pipes and remove unused log files.
  exec 101>&- 102>&- 103>&- 104>&-
  local severity=''
  for severity in INFO WARNING ERROR FATAL; do
    local path="$(imosh::internal::log_file "${severity}")"
    if [ "${path}" != '' -a ! -s "${path}" ]; then
      rm "${path}"
    fi
  done
}

trap '__imosh::exit_handler' EXIT

__imosh::signal_handler() {
  local signal="$1"
  trap - "${signal}"
  local PID=''
  func::getmypid PID
  if [ "${PID}" == "${IMOSH_ROOT_PID}" ]; then
    LOG INFO 'killing child processes.'
    __imosh::kill "${IMOSH_ROOT_PID}"
    if [ -f "${__IMOSH_CORE_TMPDIR}/status" ]; then
      exit "$(cat "${__IMOSH_CORE_TMPDIR}/status")"
    fi
  fi
  LOG ERROR "$(imosh::stack_trace "terminated by signal: ${signal}" 2>&1)"
  kill -s "${signal}" "${PID}"
}

if ! shopt login_shell >/dev/null; then
  for signal in SIGHUP SIGINT SIGPIPE SIGTERM \
                SIGXCPU SIGXFSZ SIGUSR1 SIGUSR2; do
    trap "__imosh::signal_handler ${signal}" "${signal}"
  done
fi

# Close descriptors for logs beforehand for BASH3's bug.
exec 101>&- 102>&- 103>&- 104>&-
# Open descriptors for LOG without calling init_log.
exec 101>/dev/null 102>/dev/null 103>/dev/null 104>/dev/null
# Redirect log output to the current STDERR.
exec 105>&2

# Prepares a temporary directory and sets its path to TMPDIR.
__imosh::mktemp

DEFINE_bool --group=imosh --alias=h help false \
    'Print this help message and exit.'
DEFINE_bool --group=imosh helpfull false \
    'Print all the help message.'
DEFINE_bool --group=imosh 'alsologtostderr' false \
    'Log messages go to stderr in addition to logfiles.'
DEFINE_bool --group=imosh 'logtostderr' false \
    'Log messages go to stderr instead of logfiles.'
DEFINE_string --group=imosh 'log_dir' '' \
    'Directory to output log files.  Output no files if this flag is empty.'
DEFINE_string --group=imosh 'stacktrace_threshold' 'FATAL' \
    'Threshold to show stacktrace.'
DEFINE_string --group=imosh 'help_format' '' \
    'Help format to output.'

__IMOSH_IS_LOADED=1

LOG INFO 'imosh is ready.'

