# imosh - Libraries for BASH.


imosh::internal::style() {
  echo -en "\\033[${1}m"
}

IMOSH_COLOR_DEFAULT="$(imosh::internal::style '0;39')"
IMOSH_COLOR_BLACK="$(imosh::internal::style '0;30')"
IMOSH_COLOR_RED="$(imosh::internal::style '0;31')"
IMOSH_COLOR_GREEN="$(imosh::internal::style '0;32')"
IMOSH_COLOR_YELLOW="$(imosh::internal::style '0;33')"
IMOSH_COLOR_BLUE="$(imosh::internal::style '0;34')"
IMOSH_COLOR_MAGENTA="$(imosh::internal::style '0;35')"
IMOSH_COLOR_CYAN="$(imosh::internal::style '0;36')"
IMOSH_COLOR_WHITE="$(imosh::internal::style '0;37')"


imosh::shell_escape() {
  local arg
  local search="'"
  local replace="'\"'\"'"
  for arg in "$@"; do
    arg="${arg//${search}/${replace}}"
    echo "'${arg}'"
  done
}


imosh::on_exit() {
  echo "$@" >>"${TMPDIR}/on_exit.sh"
}

imosh::internal::error_handler() {
  imosh::stack_trace "error status: $?"
}

imosh::internal::exit_handler() {
  set +e
  if [ -f "${TMPDIR}/on_exit.sh" ]; then
    source "${TMPDIR}/on_exit.sh"
  fi
  rm -rf "${TMPDIR}"
}

imosh::internal::signal_handler() {
  local signal="$1"
  imosh::stack_trace "terminated by signal: ${signal}"
  trap - "${signal}"
  kill -s "${signal}" $$
  # exit 130
}

trap imosh::internal::exit_handler EXIT
trap imosh::internal::error_handler ERR
for signal in SIGHUP SIGINT SIGPIPE SIGTERM SIGXCPU SIGXFSZ SIGUSR1 SIGUSR2; do
  trap "imosh::internal::signal_handler ${signal}" "${signal}"
done


LOG() {
  local level="$1"
  shift

  case "${level}" in
    INFO|WARNING|ERROR|FATAL) :;;
    *) LOG FATAL "no such log level: ${level}"
  esac
  local datetime="$(date +'%m%d %T.%N')"
  # For systems not supporting %N in date.
  datetime="${datetime/.N/.000000}"
  local message=(
      "${level:0:1}${datetime}"
      "$$"
      "${BASH_SOURCE[1]}:${BASH_LINENO[0]}]"
      "$*")
  echo "${message[@]}" >&2
  if [ "${level}" == 'FATAL' ]; then
    imosh::stack_trace '*** Check failure stack trace: ***'
    exit 1
  fi
}


# Shows a stack trace.  Arguments are used as a message.
imosh::stack_trace() {
  local max_depth="${#BASH_LINENO[@]}"
  local i=0
  if [ "$*" == '' ]; then
    echo 'imosh::stack_trace is called' >&2
  else
    echo "$*" >&2
  fi
  while (( i < max_depth - 1 )); do
    local lineno="${BASH_LINENO[$((i))]}"
    local file="${BASH_SOURCE[$((i+1))]}"
    local function="${FUNCNAME[$((i+1))]}"
    echo "  at ${function} (${file}:${lineno})" >&2
    ((i+=1))
  done
}


TMPDIR="${TMPDIR%/}"
export TMPDIR="$(mktemp -d "${TMPDIR:-/tmp}/imosh.XXXXXX")"

if [ "${TMPDIR}" == '' -o  "${TMPDIR}" == '/' ]; then
  LOG FATAL 'failed to create a temporary directory.'
fi

imosh::on_exit 'rm -rf ${TMPDIR}'


# Parses arguments without getopt.
imosh::internal::parse_flags() {
  local flag flag_name flag_value
  IMOSH_ARGV=()
  IMOSH_FLAGS=()
  while [ "$#" != '0' ]; do
    local flag="$1"
    shift
    if [ "${flag:0:1}" != '-' ]; then
      IMOSH_ARGV+=("$flag")
      continue
    fi
    if [ "${flag}" == '--' ]; then
      IMOSH_ARGV+=("$@")
    fi
    case "${flag}" in
      --*) flag="${flag:2}";;
      -*) flag="${flag:1}";;
    esac
    flag_name="$(cut -d= -f1 <<< "${flags}")"
    flag_value="${flag:${#flag_name}}"
    if [ "${flag_value:0:1}" != '=' ]; then
      IMOSH_FLAGS+=("FLAGS_${flag_name}=1")
      if [ "${flag_name:0:2}" == 'no' ]; then
        IMOSH_FLAGS+=("FLAGS_${flag_name:2}=0")
      fi
      continue
    fi
    IMOSH_FLAGS+=("FLAGS_${flag_name}=$(imosh::shell_escape "${flag_value:1}")")
  done
}

alias imosh::parse_arguments='
    local IMOSH_ARGV IMOSH_FLAGS
    imosh::internal::parse_flags "$@"
    local "${IMOSH_FLAGS[@]}"
    set -- "${IMOSH_ARGV}'


