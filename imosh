#!/bin/bash
# imos is a utility library for BASH.

IMOSH_VERSION='2014-09-23 20:26:57 +0900 (ecf9064)'

if ! shopt login_shell >/dev/null; then
  set -e -u
fi

if [ "${__IMOSH_IS_LOADED+loaded}" = 'loaded' ]; then
  return
fi
__IMOSH_IS_LOADED=loaded

print() {
  printf "%s" "$*"
}

__IMOSH_PROGRAM_NAME="${0##*/}"
__IMOSH_HOSTNAME="$(hostname -s)"
__IMOSH_USER="$(whoami)"
__IMOSH_LOG_PREFIX="${__IMOSH_PROGRAM_NAME}.${__IMOSH_HOSTNAME}.${__IMOSH_USER}"
__IMOSH_LOG_SUFFIX="$(date +'%Y%m%d.%H%M%S').$$"

imosh::internal::log_file() {
  local severity="${1}"
  local path=''
  if [ "${FLAGS_log_dir}" == '' ]; then
    return
  fi
  path+="${FLAGS_log_dir}/"
  path+="${__IMOSH_LOG_PREFIX}.${severity}.${__IMOSH_LOG_SUFFIX}"
  print "${path}"
}

imosh::internal::init_log() {
  # Close descriptors for logs beforehand for BASH3's bug.
  exec 101>&- 102>&- 103>&- 104>&-
  if [ "${FLAGS_log_dir}" != '' -a -w "${FLAGS_log_dir}" ]; then
    exec 101>"$(imosh::internal::log_file INFO)"
    exec 102>"$(imosh::internal::log_file WARNING)"
    exec 103>"$(imosh::internal::log_file ERROR)"
    exec 104>"$(imosh::internal::log_file FATAL)"
    return
  fi
  exec 101>/dev/null 102>/dev/null 103>/dev/null 104>/dev/null
  if [ "${FLAGS_log_dir}" == '' ]; then
    return
  fi
  LOG ERROR "failed to open files to write logs: ${__IMOSH_LOG_DIR}"
}

# Close descriptors for logs beforehand for BASH3's bug.
exec 101>&- 102>&- 103>&- 104>&-
# Open descriptors for LOG without calling init_log.
exec 101>/dev/null 102>/dev/null 103>/dev/null 104>/dev/null

__IMOSH_STACK_TRACED=0

imosh::on_exit() {
  echo "$@" >>"${__IMOSH_CORE_TMPDIR}/on_exit.sh"
}

imosh::internal::error_handler() {
  __IMOSH_STACK_TRACED=1
  imosh::stack_trace "error status: $?"
}

imosh::internal::exit_handler() {
  local exit_code="$?"
  if (( exit_code && ! __IMOSH_STACK_TRACED )); then
    imosh::stack_trace "error status: ${exit_code}"
  fi
  LOG INFO "finalizing..."

  set +e
  if [ -f "${__IMOSH_CORE_TMPDIR}/on_exit.sh" ]; then
    source "${__IMOSH_CORE_TMPDIR}/on_exit.sh"
  fi
  rm -rf "${__IMOSH_CORE_TMPDIR}"

  # Close log pipes and remove unused log files.
  exec 101>&- 102>&- 103>&- 104>&-
  local severity=''
  for severity in INFO WARNING ERROR FATAL; do
    local path="$(imosh::internal::log_file "${severity}")"
    if [ "${path}" != '' -a ! -s "${path}" ]; then
      rm "${path}"
    fi
  done
}

imosh::internal::signal_handler() {
  local signal="$1"
  trap - "${signal}"
  imosh::set_pid
  if [ "${IMOSH_PID}" == "${IMOSH_ROOT_PID}" ]; then
    LOG INFO 'killing child processes.'
    imosh::internal::kill "${IMOSH_ROOT_PID}"
    if [ -f "${__IMOSH_CORE_TMPDIR}/status" ]; then
      exit "$(cat "${__IMOSH_CORE_TMPDIR}/status")"
    fi
  fi
  LOG ERROR "$(imosh::stack_trace "terminated by signal: ${signal}" 2>&1)"
  kill -s "${signal}" "${IMOSH_PID}"
}

trap imosh::internal::exit_handler EXIT
trap imosh::internal::error_handler ERR
if ! shopt login_shell >/dev/null; then
  for signal in SIGHUP SIGINT SIGPIPE SIGTERM \
                SIGXCPU SIGXFSZ SIGUSR1 SIGUSR2; do
    trap "imosh::internal::signal_handler ${signal}" "${signal}"
  done
fi

IMOSH_ROOT_PID="$$"

imosh::internal::kill() {
  local pid="$1"
  LOG INFO "killing ${pid}..."
  local keep_alive=0
  if [ "${pid}" == "${IMOSH_PID}" -o "${pid}" == "${IMOSH_ROOT_PID}" ]; then
    keep_alive=1
  fi
  if (( ! keep_alive )); then
    kill -STOP "${pid}" 2>/dev/null || true
  fi
  local child_pids="$(
      ps -o ppid,pid | grep "^${pid}[[:space:]]" | awk '{ print $2 }')"
  if [ "${child_pids}" != '' ]; then
    local child
    for child in ${child_pids}; do
      imosh::internal::kill "${child}"
    done
  fi
  if (( ! keep_alive )); then
    kill -KILL "${pid}" 2>/dev/null || true
  fi
}

imosh::quiet_die() {
  local status='0'
  if [ "$#" -ge 1 ]; then
    status="$1"
  fi

  LOG INFO 'exiting...'
  imosh::set_pid
  echo "${status}" >"${__IMOSH_CORE_TMPDIR}/status"
  imosh::internal::kill "${IMOSH_PID}"
  imosh::internal::kill "${IMOSH_ROOT_PID}"
  kill -TERM "${IMOSH_ROOT_PID}" 2>/dev/null || true
  exit "${status}"
}

imosh::die() {
  local status='0'
  if [ "$#" -ge 1 ]; then
    status="$1"
  fi

  imosh::stack_trace "*** imosh::die stack trace: ***"
  imosh::quiet_die "${status}"
}

imosh::internal::loglevel() {
  case "$1" in
    ALL)     echo 0;;
    INFO)    echo 1;;
    WARNING) echo 2;;
    ERROR)   echo 3;;
    FATAL)   echo 4;;
    NONE)    echo 5;;
    *)       LOG FATAL "unknown level: $1";;
  esac
}

LOG() {
  local level="$1"
  shift

  case "${level}" in
    INFO|WARNING|ERROR|FATAL) :;;
    *) LOG FATAL "no such log level: ${level}"
  esac
  local datetime="$(date +'%m%d %T.%N')"
  # For systems not supporting %N in date.
  datetime="${datetime/.N/.000000}"
  datetime="${datetime:0:20}"
  local pid
  if func::isset __IMOSH_LOG_PID; then
    pid="${__IMOSH_LOG_PID}"
  else
    imosh::set_pid
    pid="${IMOSH_PID}"
  fi
  local file="${BASH_SOURCE[1]##*/}"
  if [ "${file}" = '' ]; then file='-'; fi
  local message=(
      "${level:0:1}${datetime}"
      "${pid}"
      "${file}:${BASH_LINENO[0]}]"
      "$@")
  message="$(echo "${message[@]}")"
  if [ "$(imosh::internal::loglevel "${level}")" -ge \
       "$(imosh::internal::loglevel "${FLAGS_stacktrace_threshold}")" ]; then
    message+=$'\n'
    message+="$(imosh::stack_trace "*** LOG ${level} stack trace: ***" 2>&1)"
  fi
  local logtostderr=0
  if func::isset FLAGS_logtostderr; then
    logtostderr="${FLAGS_logtostderr}"
  fi
  local alsologtostderr=0
  if func::isset FLAGS_alsologtostderr; then
    alsologtostderr="${FLAGS_alsologtostderr}"
  fi
  case "${level}" in
    INFO)
      if (( logtostderr || alsologtostderr )); then
        echo "${message}" >&2
      fi
      if (( ! logtostderr )); then
        echo "${message}" >&101
      fi
      ;;
    WARNING)
      if (( logtostderr || alsologtostderr )); then
        echo "${message}" >&2
      fi
      if (( ! logtostderr )); then
        echo "${message}" >&101
        echo "${message}" >&102
      fi
      ;;
    ERROR)
      echo "${message}" >&2
      if (( ! logtostderr )); then
        echo "${message}" >&101
        echo "${message}" >&102
        echo "${message}" >&103
      fi
      ;;
    FATAL)
      echo "${message}" >&2
      if (( ! logtostderr )); then
        echo "${message}" >&101
        echo "${message}" >&102
        echo "${message}" >&103
        echo "${message}" >&104
      fi
      imosh::quiet_die 1
      ;;
  esac
}

# Parses arguments without getopt.
imosh::internal::parse_args() {
  local class_name="$1"; shift

  local upper_class_name="${class_name}"
  func::strtoupper upper_class_name
  local arg arg_name arg_value
  IMOSH_ARGV=()
  IMOSH_ARGS=()
  while [ "$#" != '0' ]; do
    local arg="$1"
    shift
    if [ "${arg:0:1}" != '-' ]; then
      IMOSH_ARGV+=("${arg}")
      continue
    fi
    if [[ "${arg}" =~ ^-[0-9] ]]; then
      IMOSH_ARGV+=("${arg}")
      continue
    fi
    if [ "${arg}" = '--' ]; then
      IMOSH_ARGV+=("$@")
      break
    fi
    case "${arg}" in
      --*) arg="${arg:2}";;
      -*) arg="${arg:1}";;
    esac
    arg_name="${arg%%=*}"
    if [[ ! "${arg_name}" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
      LOG FATAL "${class_name} name is bad: ${arg_name}"
    fi
    arg_value="${arg:${#arg_name}}"
    if [ "${arg_value:0:1}" != '=' ]; then
      if [ "${arg_name:0:2}" = 'no' ]; then
        if func::isset "${upper_class_name}S_${arg_name:2}"; then
          if [ "${class_name}" != 'flag' ] || \
             [ "$(imosh::internal::flag_type "${arg_name:2}")" = 'bool' ]; then
            IMOSH_ARGS+=("${upper_class_name}S_${arg_name:2}=0")
            continue
          fi
        fi
      fi
      if func::isset "${upper_class_name}S_${arg_name}"; then
        if [ "${class_name}" != 'flag' ] ||
           [ "$(imosh::internal::flag_type "${arg_name}")" = 'bool' ]; then
          IMOSH_ARGS+=("${upper_class_name}S_${arg_name}=1")
          continue
        fi
      fi
      if ! func::isset "${upper_class_name}S_${arg_name}"; then
        LOG FATAL "no such bool ${class_name} is defined:" \
                  "(${upper_class_name}S_)${arg_name}"
      fi
      if [ "$#" -eq 0 ]; then
        LOG FATAL "the ${arg_name} flag requires a value"
      fi
      arg_value="=${1}"
      shift
    fi
    arg_value="${arg_value:1}"
    if func::isset "${upper_class_name}S_${arg_name}"; then
      if [ "${class_name}" = 'flag' ]; then
        if ! imosh::internal::convert_type \
               "$(imosh::internal::flag_type "${arg_name}")" \
               "${arg_value}" >/dev/null; then
          LOG FATAL "the ${arg_name} flag has an invalid value: ${arg_value}"
        else
          arg_value="$(imosh::internal::convert_type \
                             "$(imosh::internal::flag_type "${arg_name}")" \
                             "${arg_value}")"
        fi
      fi
      IMOSH_ARGS+=("${upper_class_name}S_${arg_name}=${arg_value}")
      continue
    fi
    LOG FATAL "no such ${class_name} is defined:" \
              "(${upper_class_name}S_)${arg_name}"
  done
}

readonly IMOSH_PARSE_ARGUMENTS='
    local IMOSH_ARGV IMOSH_ARGS
    imosh::internal::parse_args arg "$@"
    if [ "${#IMOSH_ARGS[@]}" -ne 0 ]; then
      readonly "${IMOSH_ARGS[@]}"
    fi
    if [ "${#IMOSH_ARGV[@]}" -ne 0 ]; then
      set -- "${IMOSH_ARGV[@]}"
    fi'

php::array_unique() {
  if [ "$#" -ne 1 ]; then
    LOG FATAL 'php::array_unique requires one argument.'
  fi

  local __array_unique_name="${1}"
  eval "local __array_unique_values=(\"\${${__array_unique_name}[@]}\")"
  php::sort __array_unique_values
  local __array_unique_i=1 __array_unique_size="${#__array_unique_values[@]}"
  while (( __array_unique_i < __array_unique_size )); do
    local __array_unique_last_i=0
    (( __array_unique_last_i = __array_unique_i - 1 )) || true
    if [ "${__array_unique_values[${__array_unique_i}]}" == \
         "${__array_unique_values[${__array_unique_last_i}]}" ]; then
      unset __array_unique_values["${__array_unique_last_i}"]
    fi
    (( __array_unique_i += 1 )) || true
  done
  eval "${__array_unique_name}=(\"\${__array_unique_values[@]}\")"
}

php::md5() {
  if which openssl >/dev/null 2>/dev/null; then
    print "${1}" | openssl md5 -binary | func::bin2hex
  elif which md5sum >/dev/null 2>/dev/null; then
    print "${1}" | md5sum -b | func::bin2hex
  else
    LOG FATAL 'no command for md5 is found.'
  fi
}

php::internal::set_pivot() {
  local pivot_index=0
  (( pivot_index = left + (right - left) / 2 )) || true
  local x="${__sort_values[${left}]}"
  local y="${__sort_values[${pivot_index}]}"
  local z="${__sort_values[${right}]}"

  if [ "${x}" \< "${y}" ]; then
    if [ "${y}" \< "${z}" ]; then
      pivot="${y}"
    elif [ "${z}" \< "${x}" ]; then
      pivot="${x}"
    else
      pivot="${z}"
    fi
  else
    if [ "${z}" \< "${y}" ]; then
      pivot="${y}"
    elif [ "${x}" \< "${z}" ]; then
      pivot="${x}"
    else
      pivot="${z}"
    fi
  fi
}

php::internal::quick_sort() {
  local left="${1}" right="${2}"
  local i="${left}" j="${right}"
  if [ "${left}" -ge "${right}" ]; then return; fi
  local pivot=''
  php::internal::set_pivot
  while :; do
    while [ "${__sort_values[${i}]}" \< "${pivot}" ]; do
      (( i += 1 )) || true
    done
    while [ "${pivot}" \< "${__sort_values[${j}]}" ]; do
      (( j -= 1 )) || true
    done
    if [ "${i}" -ge "${j}" ]; then break; fi
    local value="${__sort_values[${i}]}"
    __sort_values["${i}"]="${__sort_values[${j}]}"
    __sort_values["${j}"]="${value}"
    (( i += 1 )) || true
    (( j -= 1 )) || true
  done
  (( i -= 1 )) || true
  (( j += 1 )) || true
  php::internal::quick_sort "${left}" "${i}"
  php::internal::quick_sort "${j}" "${right}"
}

php::sort() {
  local __sort_name="${1}"
  eval "local __sort_values=(\"\${${__sort_name}[@]}\")"
  local __sort_size="${#__sort_values[@]}"
  (( __sort_size -= 1 )) || true
  php::internal::quick_sort 0 "${__sort_size}"
  eval "${__sort_name}=(\"\${__sort_values[@]}\")"
}

imosh::set_pid() {
  if func::isset BASHPID; then
    IMOSH_PID="${BASHPID}"
  else
    local pid_file="$(mktemp "${__IMOSH_CORE_TMPDIR}/pid.XXXXXX")"
    "${SHELL}" -c 'echo "${PPID}"' >"${pid_file}"
    IMOSH_PID="$(cat "${pid_file}")"
  fi
}

# __IMOSH_FLAGS_TYPE_<flag name>=<flag type>
# __IMOSH_FLAGS_DESCRIPTION_<flag name>=<description>
# __IMOSH_FLAGS_ALIASES=(from:to ...)

imosh::internal::flag_type() {
  local name="$1"

  if [ "$#" -ne 1 ]; then
    LOG FATAL 'flag_type requires 1 arugument.'
  fi
  eval print '${__IMOSH_FLAGS_TYPE_'"${name}"'}'
}

imosh::internal::define_flag() {
  local type="$1"; shift

  local ARGS_alias='' ARGS_alias_flag=0 ARGS_group='main'
  eval "${IMOSH_PARSE_ARGUMENTS}"

  if [ "$#" -lt 3 ]; then
    LOG FATAL 'DEFINE_${type} requires 3+ arguments.'
  fi
  local name="$1"; shift
  local default_value="$1"; shift
  local description="$*"
  local group="${ARGS_group}"
  func::strtoupper group

  # Change the default value based on its corresponding environment variable.
  if func::isset "IMOSH_FLAGS_${name}"; then
    default_value="$(eval print "\${IMOSH_FLAGS_${name}}")"
  fi
  if ! imosh::internal::convert_type \
           "${type}" "${default_value}" >/dev/null; then
    LOG FATAL "${type}'s default value should be ${type}: ${default_value}"
  fi
  default_value="$(imosh::internal::convert_type "${type}" "${default_value}")"
  if func::isset "__IMOSH_FLAGS_TYPE_${name}"; then
    LOG FATAL "already defined flag: ${name}"
  fi
  func::strcpy "FLAGS_${name}" 'default_value'
  func::strcpy "__IMOSH_FLAGS_TYPE_${name}" 'type'
  if [ "${ARGS_alias}" != '' ]; then
    imosh::internal::define_flag "${type}" --alias_flag \
        "${ARGS_alias}" "${default_value}" "${description}"
    __IMOSH_FLAGS_ALIASES+=("${name}:${ARGS_alias}")
  fi
  if (( ! ARGS_alias_flag )); then
    local escaped_default_value=''
    case "${type}" in
      int) escaped_default_value="${default_value}";;
      bool)
        if (( default_value )); then
          escaped_default_value='true'
        else
          escaped_default_value='false'
        fi
        ;;
      *)
        escaped_default_value="${default_value}"
        func::escapeshellarg escaped_default_value
        ;;
    esac
    func::let "__IMOSH_FLAGS_DEFAULT_${name}" \
              "--${name}=${escaped_default_value}"
    if [ "${ARGS_alias}" != '' ]; then
      description+=" (Alias: --${ARGS_alias})"
    fi
    func::let "__IMOSH_FLAGS_DESCRIPTION_${name}" "${description}"
    __IMOSH_FLAGS+=("${group}:${name}")
  fi
}

DEFINE_string() { imosh::internal::define_flag string "$@"; }
DEFINE_int() { imosh::internal::define_flag int "$@"; }
DEFINE_bool() { imosh::internal::define_flag bool "$@"; }
DEFINE_double() { imosh::internal::define_flag double "$@"; }

imosh::internal::get_main_script() {
  local depth="${#BASH_SOURCE[@]}"
  local main_script="${BASH_SOURCE[$((depth-1))]}"
  echo "${main_script}"
}

imosh::internal::get_usage() {
  local file="${1}"
  grep --max-count=1 -B 1000 -v '^#' "${file}" | grep '^#' | while read line; do
    case "${line}" in
      '#!'*) continue;;
      '# '*) echo "${line:2}";;
      '#'*) echo "${line:1}";;
    esac
  done > "${__IMOSH_CORE_TMPDIR}/usage"
  if [ -s "${__IMOSH_CORE_TMPDIR}/usage" ]; then
    cat "${__IMOSH_CORE_TMPDIR}/usage"
  else
    echo 'No description.'
  fi
}

imosh::internal::flag_groups() {
  local groups=()
  local group=''
  local main_group_exists=0
  local imosh_group_exists=0
  for flag_name in "${__IMOSH_FLAGS[@]}"; do
    local parts=()
    func::explode parts ':' "${flag_name}"
    group="${parts[0]}"
    local lower_group="${group}"
    func::strtolower lower_group
    if [ "${lower_group}" == 'main' ]; then
      main_group_exists=1
    elif [ "${lower_group}" == 'imosh' ]; then
      imosh_group_exists=1
    else
      groups+=("${group}")
    fi
  done
  if (( main_group_exists )); then
    echo 'main'
  fi
  if [ "${#groups[@]}" -ne 0 ]; then
    php::array_unique groups
    for group in "${groups[@]}"; do
      echo "${group}"
    done
  fi
  if (( imosh_group_exists )); then
    echo 'imosh'
  fi
}

imosh::internal::group_flags() {
  local group="$1"
  local lower_group="${group}"
  func::strtolower lower_group

  local flags=()
  for flag_name in "${__IMOSH_FLAGS[@]}"; do
    local parts=()
    func::explode parts ':' "${flag_name}"
    local lower_part="${parts[0]}"
    func::strtolower lower_part
    if [ "${lower_group}" != "${lower_part}" ]; then
      continue
    fi
    flags+=("${parts[1]}")
  done
  php::sort flags
  for flag in "${flags[@]}"; do
    echo "${flag}"
  done
}

imosh::internal::man() {
  echo ".TH ${0##*/} 1"; echo
  echo '.SH SYNOPSIS'
  echo ".B ${0##*/}"; echo '[\fIOPTIONS\fP] [\fIargs...\fP]'; echo

  echo '.SH DESCRIPTION'
  imosh::internal::get_usage "$(imosh::internal::get_main_script)"

  echo '.SH OPTIONS'
  for flag_group in $(imosh::internal::flag_groups); do
    local upper_flag_group="${flag_group}"
    func::strtoupper upper_flag_group
    echo ".SS ${upper_flag_group} OPTIONS"
    for flag_name in $(imosh::internal::group_flags "${flag_group}"); do
      echo '.TP'
      echo -n '\fB'
      eval "echo -n \"\${__IMOSH_FLAGS_DEFAULT_${flag_name}}\""
      echo '\fP'
      eval "echo \"\${__IMOSH_FLAGS_DESCRIPTION_${flag_name}}\""
      echo
    done
  done
}

imosh::internal::help() {
  echo "USAGE: ${0##*/} [options...] [args...]"
  echo
  echo 'DESCRIPTION:'
  imosh::internal::get_usage "$(imosh::internal::get_main_script)" | \
      while read line; do
    echo "  ${line}"
  done
  echo
  echo "OPTIONS:"
  for flag_group in $(imosh::internal::flag_groups); do
    local upper_flag_group="${flag_group}"
    func::strtoupper upper_flag_group
    echo "  ${upper_flag_group} OPTIONS:"
    for flag_name in $(imosh::internal::group_flags "${flag_group}"); do
      eval "echo -n \"    \${__IMOSH_FLAGS_DEFAULT_${flag_name}}:\""
      eval "echo \" \${__IMOSH_FLAGS_DESCRIPTION_${flag_name}}\""
    done
  done
}

imosh::internal::init() {
  imosh::internal::parse_args flag "$@"
  if [ "${#IMOSH_ARGS[@]}" -ne 0 ]; then
    eval "${IMOSH_ARGS[@]}"
  fi
  imosh::internal::init_log
  if [ "${#__IMOSH_FLAGS_ALIASES[@]}" -ne 0 ]; then
    for alias in "${__IMOSH_FLAGS_ALIASES[@]}"; do
      eval "FLAGS_${alias%%:*}=\"\${FLAGS_${alias#*:}}\""
      unset "FLAGS_${alias#*:}"
    done
  fi
  if [ "${#IMOSH_ARGS[@]}" -ne 0 ]; then
    eval "${IMOSH_ARGS[@]}"
  fi
  if (( FLAGS_help )); then
    if [ -t 1 ]; then
      local man_file="${__IMOSH_CORE_TMPDIR}/man"
      imosh::internal::man >"${man_file}"
      man "${man_file}"
    elif (( FLAGS_help_groff )); then
      imosh::internal::man
    else
      imosh::internal::help >&2
    fi
    exit 0
  fi
}

readonly IMOSH_INIT='
    set -e -u
    imosh::internal::init "$@"
    if [ "${#IMOSH_ARGV[@]}" -ne 0 ]; then
      set -- "${IMOSH_ARGV[@]}"
    fi'

__IMOSH_FLAGS=()
__IMOSH_FLAGS_ALIASES=()

imosh::mktemp() {
  TMPDIR="${TMPDIR%/}"
  export IMOSH_TMPDIR="$(mktemp -d "${TMPDIR:-/tmp}/imosh.XXXXXX")"
  if [ "${IMOSH_TMPDIR}" = '' -o  "${IMOSH_TMPDIR}" = '/' ]; then
    LOG FATAL 'failed to create a temporary directory.'
  fi

  export __IMOSH_CORE_TMPDIR="${IMOSH_TMPDIR}/.imosh"
  mkdir "${__IMOSH_CORE_TMPDIR}"
  imosh::on_exit "rm -rf ${IMOSH_TMPDIR}"
}

TMPDIR="${TMPDIR:-/tmp}"
export TMPDIR="${TMPDIR%/}"
imosh::mktemp

__IMOSH_PHP_EXECUTER_PID=''

php::internal::kill() {
  if (( FLAGS_disown_php )); then
    if [ "${__IMOSH_PHP_EXECUTER_PID}" = "$$" ]; then
      # Make sure that the target process exists.
      if kill -0 "$(cat "${__IMOSH_PHP_PID}")" 2>/dev/null; then
        php::internal::run 'exit(0);'
        kill -TERM "$(cat "${__IMOSH_PHP_PID}")" 2>/dev/null
      fi
    fi
  fi
}

php::internal::run() {
  local __php_code="$1"
  local __php_name=''
  if [ "$#" -ge 2 ]; then __php_name="$2"; fi

  local __php_line __php_return_code
  local __php_new_line=$'\n'
  __php_code="${__php_code//@/@@}"
  __php_code="${__php_code//${__php_new_line}/@n}"
  if (( FLAGS_disown_php )); then
    php::internal::start
    printf "%s\n" "${__php_code}" >&111
    read __php_line <&110
    read __php_return_code <&110
  else
    while :; do
      read __php_line
      read __php_return_code
      break
    done < <(printf "%s\n" "${__php_code}" |  php::internal::start)
  fi

  if [ "${__php_name}" != '' ]; then
    eval "${__php_name}=${__php_line//@/\\}"
  fi
  if [ "${__php_return_code}" = '' ]; then return 1; fi
  return "${__php_return_code}"
}

php::internal::start() {
  if (( FLAGS_disown_php )); then
    if [ "${__IMOSH_PHP_EXECUTER_PID}" = "$$" ]; then
      # Make sure that the target process exists.
      if kill -0 "$(cat "${__IMOSH_PHP_PID}")" 2>/dev/null; then
        return;
      fi
    fi
    exec 111>&- 110<&-
    __IMOSH_PHP_STDIN="$(mktemp "${__IMOSH_CORE_TMPDIR}/php_stdin.XXXXXX")"
    __IMOSH_PHP_STDOUT="$(mktemp "${__IMOSH_CORE_TMPDIR}/php_stdout.XXXXXX")"
    __IMOSH_PHP_EXECUTER_PID="$$"
    __IMOSH_PHP_PID="$(mktemp "${__IMOSH_CORE_TMPDIR}/php_pid.XXXXXX")"
    rm "${__IMOSH_PHP_STDIN}" "${__IMOSH_PHP_STDOUT}"
  fi
  local php_script="$(mktemp "${__IMOSH_CORE_TMPDIR}/php_script.XXXXXX")"
  cat << 'EOM' >"${php_script}"
<?php

function imosh_chop($str) { return substr($str, 0, strlen($str) - 1); }

$translate = array(
  "\r" => '@r', "\n" => '@n', '\\' => '@@',
  '"' => '@x22', "'" => "@x27", '@' => '@x40');

while (($line = fgets(STDIN)) !== FALSE) {
  $line = strtr($line, array('@@' => '@', '@n' => "\n"));
  ob_start();
  $value = eval($line);
  $output = ob_get_clean();
  echo "\$'" . strtr($output, $translate) . "'\n";
  echo intval($value) . "\n";
  if (isset($argv[1]) && $argv[1] == 'once') exit(0);
}

EOM
  LOG INFO 'Starting to run php...'
  if (( ! FLAGS_disown_php )); then
    php "${php_script}" once
    return
  fi
  mkfifo "${__IMOSH_PHP_STDIN}"
  mkfifo "${__IMOSH_PHP_STDOUT}"
  bash -c "nohup php '${php_script}' \
               <'${__IMOSH_PHP_STDIN}' \
               >'${__IMOSH_PHP_STDOUT}' &
           echo \$! >'${__IMOSH_PHP_PID}'"
  LOG INFO "Opening PHP's STDIN..."
  exec 111>"${__IMOSH_PHP_STDIN}"
  LOG INFO "Opening PHP's STDOUT..."
  exec 110<"${__IMOSH_PHP_STDOUT}"
}

php::stop() {
  php::internal::kill
}

php::start() {
  if (( FLAGS_disown_php )); then
    php::internal::start
  fi
}

# Color definitions.  A shell script should restore terminal's original color
# using IMOSH_STYLE_DEFAULT when it changes color or style.

IMOSH_STYLE_DEFAULT=$'\033[0m'
IMOSH_COLOR_DEFAULT=$'\033[0;39m'
IMOSH_COLOR_BLACK=$'\033[0;30m'
IMOSH_COLOR_RED=$'\033[0;31m'
IMOSH_COLOR_GREEN=$'\033[0;32m'
IMOSH_COLOR_YELLOW=$'\033[0;33m'
IMOSH_COLOR_BLUE=$'\033[0;34m'
IMOSH_COLOR_MAGENTA=$'\033[0;35m'
IMOSH_COLOR_CYAN=$'\033[0;36m'
IMOSH_COLOR_WHITE=$'\033[0;37m'

# Usage:
#   void func::addslashes(string* subject)
#
# Quotes string with backslashes. Single quote, double quote and backslash in
# subject are escaped.
func::addslashes() {
  func::str_replace "${1}" '\' '\\'
  func::str_replace "${1}" "'" "\\'"
  func::str_replace "${1}" '"' '\"'
}

# Usage:
#   void func::bin2hex(string* hexadecimal_output, string binary_input)
#   void func::bin2hex(string binary_input) > hexadecimal_output
#   void func::bin2hex() < binary_input > hexadecimal_output
#
# Converts binary data into hexadecimal representation.
func::bin2hex() {
  if [ "$#" -eq 0 ]; then
    od -An -tx1 | tr -d ' \n'
    return
  elif [ "$#" -eq 1 ]; then
    func::bin2hex <<<"$1"
    return
  elif [ "$#" -ne 2 ]; then
    LOG FATAL "func::bin2hex requires two arguments, but $# arguments."
    return 1
  fi
  local __bin2hex_destination="$1"
  local __bin2hex_data="$2"

  eval "${__bin2hex_destination}=\"\$(func::print \"${__bin2hex_data}\" | func::bin2hex)\""
}

# Usage:
#   void func::escapeshellarg(string* variable)
#
# Escapes variable's content.
func::escapeshellarg() {
  local __escapeshellarg_variable="$1"
  local __escapeshellarg_search="'"
  local __escapeshellarg_replace="'\\''"

  eval "${__escapeshellarg_variable}=\"'\${${__escapeshellarg_variable}//\${__escapeshellarg_search}/\${__escapeshellarg_replace}}'\""
}

# Usage:
#   void func::explode(string* variable, string delimiter, string value)
#
# Splits a string by string.
func::explode() {
  local __explode_variable="${1}"
  local __explode_delimiter="${2}"
  local __explode_value="${3}"
  local __explode_result=()

  func::str_replace __explode_value "${__explode_delimiter}" $'\x02'
  while IFS='' read -r -d $'\x02' __explode_term; do
    __explode_result+=("${__explode_term}")
  done <<<"${__explode_value}"$'\x02'
  eval "${__explode_variable}=(\"\${__explode_result[@]}\")"
}

# Usage:
#   bool func::floatval(string* variable)
#
# Casts variable into float type.  If it fails, returns 1.
func::floatval() {
  local __floatval_variable="$1"

  local __floatval_value
  eval "__floatval_value=\"\${${__floatval_variable}}\""
  if [[ "${__floatval_value}" =~ ^[[:space:]]*(-?[0-9]+(\.[0-9]+)?) ]]; then
    func::let "${__floatval_variable}" "${BASH_REMATCH[1]}"
  else
    return 1
  fi
}

# Usage:
#   void func::greg_match(string pattern, string subject)
#
# Replace pattern with replace in *subject.
func::greg_match() {
  if ! shopt extglob >/dev/null; then
    shopt -s extglob
    func::greg_match "$@"
    local result="$?"
    shopt -u extglob
    return "${result}"
  fi

  if [ "$#" -ne 2 ]; then
    LOG FATAL 'func::greg_match takes exactly 2 arguments.'
  fi
  local __greg_match_pattern="${1}"
  local __greg_match_subject="${2}"

  if [[ "${__greg_match_subject}" = ${__greg_match_pattern} ]]; then
    return 0
  else
    return 1
  fi
}

# Usage:
#   void func::greg_replace(string* subject, string pattern, string replace)
#
# Replace pattern with replace in *subject.
func::greg_replace() {
  if ! shopt extglob >/dev/null; then
    shopt -s extglob
    func::greg_replace "$@"
    shopt -u extglob
    return "$?"
  fi

  if [ "$#" -ne 3 ]; then
    LOG FATAL 'func::greg_replace takes exactly 3 arguments.'
  fi
  local __greg_replace_subject_variable="${1}"
  local __greg_replace_search="${2}"
  local __greg_replace_replace="${3}"

  eval "${__greg_replace_subject_variable}=\"\${${__greg_replace_subject_variable}//\${__greg_replace_search}/\${__greg_replace_replace}}\""
}

# Usage:
#   void func::hex2bin(string* output, string input)
#   void func::hex2bin(string* variable)
#   void func::hex2bin() < input > output
#
# Decodes a hexadecimally encoded binary string.
func::hex2bin() {
  if [ "$#" -eq 0 ]; then
    local __hex2bin_variable=''
    __func::hex2bin
  elif [ "$#" -eq 2 ]; then
    local __hex2bin_variable="$1" __hex2bin_data="$2" __hex2bin_result=''
    __func::hex2bin <<<"${__hex2bin_data}"
    func::let "${__hex2bin_variable}" "${__hex2bin_result}"
  elif [ "$#" -eq 1 ]; then
    local __hex2bin_variable="$1" __hex2bin_result=''
    eval "func::hex2bin \"\${__hex2bin_variable}\" \"\${${__hex2bin_variable}}\""
  fi
}

__func::hex2bin() {
  local __hex2bin_char='' __hex2bin_buffer=''
  while read -n 1 __hex2bin_char; do
    case "${__hex2bin_char}" in
      [0-9a-fA-F]) __hex2bin_buffer+="${__hex2bin_char}";;
      *) continue;;
    esac
    if [ "${#__hex2bin_buffer}" -eq 2 ]; then
      if [ "${__hex2bin_variable}" = '' ]; then
        printf "\\x${__hex2bin_buffer}"
      else
        eval "__hex2bin_result+=\$'\\x${__hex2bin_buffer}'"
      fi
      __hex2bin_buffer=''
    fi
  done
}

# Usage:
#   func::implode(string* variable, string glue, array* pieces)
#   func::implode(string glue, array* pieces) > result
#
# Joins array elements with a string.
func::implode() {
  if [ "$#" -eq 2 ]; then
    local __implode_output=''
    func::implode __implode_output "$1" "$2"
    func::print "${__implode_output}"
    return
  fi

  local __implode_variable="${1}"
  local __implode_glue="${2}"
  local __implode_pieces=()
  eval "local __implode_pieces=(\"\${${3}[@]}\")"

  local __implode_size="${#__implode_pieces[@]}"
  local __implode_i=0
  local __implode_result=''
  while (( __implode_i < __implode_size )); do
    if (( __implode_i != 0 )); then
      __implode_result+="${__implode_glue}"
    fi
    __implode_result+="${__implode_pieces[${__implode_i}]}"
    (( __implode_i += 1 )) || true
  done
  func::let "${__implode_variable}" "${__implode_result}"
}

# Usage:
#   bool func::intval(string* variable)
#
# Casts variable into integer type.  If it fails, returns 1.
func::intval() {
  local __intval_variable="$1"

  local __intval_value
  eval "__intval_value=\"\${${__intval_variable}}\""
  if [[ "${__intval_value}" =~ ^[[:space:]]*(-?[0-9]+) ]]; then
    func::let "${__intval_variable}" "${BASH_REMATCH[1]}"
  else
    return 1
  fi
}

# Usage:
#   bool func::isset(variant* variable)
#
# Returns true iff variable exists.
#
# CAVEATS: func::isset returns true for uninitialized variables in BASH 3, and
#          returns false for them in BASH 4.
func::isset() {
  local __isset_variable="$1"

  eval "local __isset_state=\"\${${__isset_variable}+set}\""
  if [ "${__isset_state}" = 'set' ]; then
    return 0
  fi
  return 1
}

# Usage:
#   func::let(string* destination, string value)
#
# Assigns value into *destination.
func::let() {
  local __let_destination="$1"
  local __let_value="$2"

  eval "${__let_destination}=\"\${__let_value}\""
}

# Usage:
#   void func::ltrim(string* variable)
#
# Strips whitespace (or other characters) from the beginning of a string.
func::ltrim() {
  local __ltrim_variable="$1"

  eval "${__ltrim_variable}=\"\${${__ltrim_variable}#\"\${${__ltrim_variable}%%[![:space:]]*}\"}\""
}

# Usage:
#   func::ord(string* variable, string character)
#
# Sets ASCII value of character to variable.
func::ord() {
  local __ord_variable="$1"
  local __ord_character="$2"
  local __ord_result="$(printf '%d' \'"${__ord_character}")"
  eval "${__ord_variable}=\"\${__ord_result}\""
}

# Usage:
#   void func::print(string message...) > output
#
# Print message to the standard output.  While "echo" consumes flags,
# func::print does not consume any flags, so this is theoretically safe.
func::print() {
  printf "%s" "$*"
}

# Usage:
#   void func::println(string message...) > output
#
# Print message to the standard output with a new line.  While "echo" consumes
# flags, func::println does not consume any flags, so this is theoretically
# safe.
func::println() {
  printf "%s\n" "$*"
}

# Usage:
#   void func::rand(int* variable)
#   void func::rand(int* variable, int minimum, int maximum)
#
# Generates a random integer.
func::rand() {
  if [ "$#" -eq 1 ]; then
    func::rand "$1" 0 2147483647
    return
  fi
  if [ "$#" -ne 3 ]; then
    LOG FATAL 'func::rand requires one or three arguments.'
  fi

  local __rand_variable="$1"
  local __rand_minimum="$2"
  local __rand_maximum="$3"
  local __rand_range=0 __rand_value=0
  if (( __rand_minimum > __rand_maximum )); then
    LOG FATAL "minimum must be larger than maximum:" \
              "minimum=${__rand_minimum}, maximum=${__rand_maximum}"
  fi
  (( __rand_value = RANDOM ^ (RANDOM << 8) ^
                    (RANDOM << 16) ^ (RANDOM << 24) ^
                    (RANDOM << 32) ^ (RANDOM << 40) ^
                    (RANDOM << 48) ^ (RANDOM << 56),
     __rand_range = __rand_maximum - __rand_minimum + 1,
     __rand_value = __rand_minimum +
         ( __rand_value % __rand_range + __rand_range ) % __rand_range,
     1 ))
  func::let "${__rand_variable}" "${__rand_value}"
}

# Usage:
#   void func::rtrim(string* variable)
#
# Strips whitespace (or other characters) from the end of a string.
func::rtrim() {
  local __rtrim_variable="$1"

  eval "${__rtrim_variable}=\"\${${__rtrim_variable}%\"\${${__rtrim_variable}##*[![:space:]]}\"}\""
}

__func::quick_sort() {
  local size="${#__sort_values[@]}"
  local pivot="${__sort_values[$(( size / 2 ))]}"
  local values1=() values2=() values3=()

  for value in "${__sort_values[@]}"; do
    if [ "${value}" \< "${pivot}" ]; then
      values1+=("${value}")
    elif [ "${value}" \> "${pivot}" ]; then
      values3+=("${value}")
    else
      values2+=("${value}")
    fi
  done
  func::sort values1
  func::sort values3
  __sort_values=()
  if [ "${#values1[*]}" -ne 0 ]; then
    __sort_values+=("${values1[@]}")
  fi
  if [ "${#values2[*]}" -ne 0 ]; then
    __sort_values+=("${values2[@]}")
  fi
  if [ "${#values3[*]}" -ne 0 ]; then
    __sort_values+=("${values3[@]}")
  fi
}

func::sort() {
  local __sort_name="${1}"
  eval "local __sort_size=\"\${#${__sort_name}[*]}\""
  if [ "${__sort_size}" -lt 2 ]; then
    return
  fi
  eval "local __sort_values=(\"\${${__sort_name}[@]}\")"
  __func::quick_sort
  eval "${__sort_name}=(\"\${__sort_values[@]}\")"
}

# Usage:
#   void func::str_replace(string* subject, string search, string replace)
#
# Replace search with replace in *subject.
func::str_replace() {
  if [ "$#" -ne 3 ]; then
    LOG FATAL 'func::str_replace takes exactly 3 arguments.'
  fi
  local __str_replace_subject_variable="${1}"
  local __str_replace_search="${2}"
  local __str_replace_replace="${3}"

  eval "${__str_replace_subject_variable}=\"\${${__str_replace_subject_variable}//\"\${__str_replace_search}\"/\${__str_replace_replace}}\""
}

# Usage:
#   void func::strcpy(string* destination, string *source)
#
# Assigns the content of a variable specified as source into destination.
func::strcpy() {
  local __strcpy_destination="$1"
  local __strcpy_source="$2"

  eval "${__strcpy_destination}=\"\${${__strcpy_source}}\""
}

# Usage:
#   void func::strtolower(string* variable)
#   void func::strtolower() < input > output
#
# Makes variable lowercase.
func::strtolower() {
  if [ "$#" -eq 0 ]; then
    tr '[A-Z]' '[a-z]'
    return
  fi
  local __strtolower_variable="$1"
  eval "local __strtolower_value=\"\${${__strtolower_variable}}\""
  # This is faster than tr for short strings.
  # TODO(imos): Use ${variable,,} instead once Mac OSX supports BASH 4.
  __strtolower_value="${__strtolower_value//A/a}"
  __strtolower_value="${__strtolower_value//B/b}"
  __strtolower_value="${__strtolower_value//C/c}"
  __strtolower_value="${__strtolower_value//D/d}"
  __strtolower_value="${__strtolower_value//E/e}"
  __strtolower_value="${__strtolower_value//F/f}"
  __strtolower_value="${__strtolower_value//G/g}"
  __strtolower_value="${__strtolower_value//H/h}"
  __strtolower_value="${__strtolower_value//I/i}"
  __strtolower_value="${__strtolower_value//J/j}"
  __strtolower_value="${__strtolower_value//K/k}"
  __strtolower_value="${__strtolower_value//L/l}"
  __strtolower_value="${__strtolower_value//M/m}"
  __strtolower_value="${__strtolower_value//N/n}"
  __strtolower_value="${__strtolower_value//O/o}"
  __strtolower_value="${__strtolower_value//P/p}"
  __strtolower_value="${__strtolower_value//Q/q}"
  __strtolower_value="${__strtolower_value//R/r}"
  __strtolower_value="${__strtolower_value//S/s}"
  __strtolower_value="${__strtolower_value//T/t}"
  __strtolower_value="${__strtolower_value//U/u}"
  __strtolower_value="${__strtolower_value//V/v}"
  __strtolower_value="${__strtolower_value//W/w}"
  __strtolower_value="${__strtolower_value//X/x}"
  __strtolower_value="${__strtolower_value//Y/y}"
  __strtolower_value="${__strtolower_value//Z/z}"
  eval "${__strtolower_variable}=\"\${__strtolower_value}\""
}

# Usage:
#   void func::strtoupper(string* variable)
#   void func::strtoupper() < input > output
#
# Makes variable uppercase.
func::strtoupper() {
  if [ "$#" -eq 0 ]; then
    tr '[a-z]' '[A-Z]'
    return
  fi
  local __strtoupper_variable="$1"
  eval "local __strtoupper_value=\"\${${__strtoupper_variable}}\""
  # This is faster than tr for short strings.
  # TODO(imos): Use ${variable^^} instead once Mac OSX supports BASH 4.
  __strtoupper_value="${__strtoupper_value//a/A}"
  __strtoupper_value="${__strtoupper_value//b/B}"
  __strtoupper_value="${__strtoupper_value//c/C}"
  __strtoupper_value="${__strtoupper_value//d/D}"
  __strtoupper_value="${__strtoupper_value//e/E}"
  __strtoupper_value="${__strtoupper_value//f/F}"
  __strtoupper_value="${__strtoupper_value//g/G}"
  __strtoupper_value="${__strtoupper_value//h/H}"
  __strtoupper_value="${__strtoupper_value//i/I}"
  __strtoupper_value="${__strtoupper_value//j/J}"
  __strtoupper_value="${__strtoupper_value//k/K}"
  __strtoupper_value="${__strtoupper_value//l/L}"
  __strtoupper_value="${__strtoupper_value//m/M}"
  __strtoupper_value="${__strtoupper_value//n/N}"
  __strtoupper_value="${__strtoupper_value//o/O}"
  __strtoupper_value="${__strtoupper_value//p/P}"
  __strtoupper_value="${__strtoupper_value//q/Q}"
  __strtoupper_value="${__strtoupper_value//r/R}"
  __strtoupper_value="${__strtoupper_value//s/S}"
  __strtoupper_value="${__strtoupper_value//t/T}"
  __strtoupper_value="${__strtoupper_value//u/U}"
  __strtoupper_value="${__strtoupper_value//v/V}"
  __strtoupper_value="${__strtoupper_value//w/W}"
  __strtoupper_value="${__strtoupper_value//x/X}"
  __strtoupper_value="${__strtoupper_value//y/Y}"
  __strtoupper_value="${__strtoupper_value//z/Z}"
  eval "${__strtoupper_variable}=\"\${__strtoupper_value}\""
}

# Usage:
#   void func::strval(string* variable)
#
# Casts variable into string type.
func::strval() {
  local __strval_variable="$1"

  eval "${__strval_variable}=\"\${${__strval_variable}}\""
}

# Usage:
#   void func::trim(string* variable)
#
# Strips whitespace (or other characters) from the beginning and end of a
# string.
func::trim() {
  func::rtrim "$1"
  func::ltrim "$1"
}

CHECK() {
  if ! "$@"; then
    IFS=' ' eval 'imosh::stack_trace "*** Check failure: $* ***"'
  fi
}

# Usage:
#   imosh::stack_trace [--skip_imosh] [message...]
#
# Shows a stack trace.  Arguments are used as a message.
imosh::stack_trace() {
  local ARGS_skip_imosh=0
  eval "${IMOSH_PARSE_ARGUMENTS}"

  local max_depth="${#BASH_LINENO[@]}"
  local i=0
  if [ "$*" = '' ]; then
    echo 'imosh::stack_trace is called' >&2
  else
    echo "$*" >&2
  fi
  while (( i < max_depth - 1 )); do
    if [ "${BASH_SOURCE[$((i+1))]}" != "${BASH_SOURCE[0]}" ]; then
      break
    fi
    (( i += 1 )) || true
  done
  while (( i < max_depth - 1 )); do
    local lineno="${BASH_LINENO[$((i))]}"
    local file="${BASH_SOURCE[$((i+1))]}"
    local function="${FUNCNAME[$((i+1))]}"
    echo "  at ${function} (${file}:${lineno})" >&2
    (( i += 1 )) || true
  done
}

imosh::internal::convert_type() {
  local type="$1"; shift
  local value="$1"; shift

  case "${type}" in
    int)
      if [[ "${value}" =~ ^-?[0-9]+$ ]]; then
        print "${value}"
      else
        return 1
      fi
      ;;
    string)
      print "${value}"
      ;;
    bool)
      case "${value}" in
        1|T|t|[Tt]rue) print 1;;
        0|F|f|[Ff]alse) print 0;;
        *) return 1;;
      esac
      ;;
    variant)
      print "${value}"
      ;;
    *) LOG FATAL "no such type: ${type}";;
  esac
}

DEFINE_bool --group=imosh --alias=h help false \
    'Print this help message and exit.'
DEFINE_bool --group=imosh 'alsologtostderr' false \
    'Log messages go to stderr in addition to logfiles.'
DEFINE_bool --group=imosh 'logtostderr' false \
    'Log messages go to stderr instead of logfiles.'
DEFINE_string --group=imosh 'log_dir' '' \
    'Directory to output log files.  Output no files if this flag is empty.'
DEFINE_string --group=imosh 'stacktrace_threshold' 'FATAL' \
    'Threshold to show stacktrace.'
DEFINE_bool --group=imosh 'help_groff' false \
    'Use groff for help output.'

DEFINE_bool --group=imosh disown_php false 'Disown a PHP process.'

ASSERT() {
  local last_state="${IMOSH_TEST_IS_FAILED}"
  IMOSH_TEST_IS_FAILED=0
  "$@"
  if (( IMOSH_TEST_IS_FAILED )); then
    exit 1
  fi
  IMOSH_TEST_IS_FAILED="${last_state}"
}

FAILURE() {
  IMOSH_TEST_IS_FAILED=1
  imosh::stack_trace --skip_imosh '*** Check failure ***'
}

EXPECT_TRUE() {
  if ! "$@"; then
    echo '  Actual: false' >&2
    echo 'Expected: true' >&2
    FAILURE
    return 1
  fi
}

EXPECT_FALSE() {
  if "$@"; then
    echo '  Actual: true' >&2
    echo 'Expected: false' >&2
    FAILURE
    return 1
  fi
}

ASSERT_TRUE() {
  ASSERT EXPECT_TRUE "$@"
}

ASSERT_FALSE() {
  ASSERT EXPECT_FALSE "$@"
}

LOG INFO 'imosh is ready.'

