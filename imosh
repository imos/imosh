#!/bin/bash
# imosh is a utility library for BASH.
#
# For more details, see https://github.com/imos/imosh

IMOSH_VERSION='2015-02-03 22:43:00 +0900 (ebe03c4)'

# Enables error checking if imosh is called in a script.
if ! shopt login_shell >/dev/null; then
  # Make a script fail when
  # - a command returns non-zero value (-e).
  # - an undefined variable is referred (-u).
  set -e -u
  # Return if imosh is already loaded.
  if [ "${__IMOSH_IS_LOADED+loaded}" = 'loaded' ]; then
    return
  fi
fi

# array -- Creates an array.
#
# array creates an array from a string with IFS separators.
#
# Usage:
#     // 1. Function form
#     void func::array(string[]* result, string input)
func::array() {
  if [ "$#" -eq 2 ]; then
    local __array_ifs="${IFS}"
    func::str_replace __array_ifs '[' '\['
    func::str_replace __array_ifs ']' '\]'
    func::greg_split "${1}" "[${__array_ifs}]" "${2}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# array_is_empty -- Checks if an array is empty.
#
# array_is_empty returns true iff a given array is empty.
#
# Usage:
#     // 1. Command form.
#     bool sub::array_is_empty(string[]* variable)
sub::array_is_empty() {
  if [ "$#" -eq 1 ]; then
    if eval "[ \"\${#${1}[*]}\" -eq 0 ]"; then return 0; fi
    return 1
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# array_keys -- Gets an array's keys.
#
# array_keys gets an array's keys.
#
# Usage:
#     // 1. Function form.
#     void func::array_keys(string[]* output, string[]* input)
#     // 2. Command form.
#     void sub::array_keys(string[]* input) > output
func::array_keys() {
  if [ "$#" -eq 2 ]; then
    if eval "[ \"\${#${2}[*]}\" -eq 0 ]"; then
      eval "${1}=()"
    else
      eval "${1}=(\"\${!${2}[@]}\")"
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::array_keys() {
  if [ "$#" -eq 1 ]; then
    local __array_keys_values=()
    func::array_keys __array_keys_values "${1}"
    sub::implode __array_keys_values
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# array_map -- Applies a callback to elements.
#
# array_map applies a callback to every element.  stream::array_map applies a
# callback to every line's elements.
# stream::array_map supports the following functions: array, function, inplace
# and command.
#
# Usage:
#     // 1. Function form.
#     void func::array_map(string[]* variable, string type,
#                          string callback [, string arguments...])
#     // 2. Stream form.
#     void stream::array_map(
#         string type, string callback [, string arguments...])
#         < input > output
#
# Type:
# - ARRAY
#     Reads every line as an array, and applies a callback to every line.
# - FUNCTION
#     Reads every line as a string and applies a callback.  A callback should be
#     a function format like: function(string* output, input).
# - INPLACE
#     Reads every line as a string and applies a callback.  A callback should be
#     an inplace format like: function(string* input_and_output).
# - COMMAND
#     Reads every line as a string and applies a callback.  A callback should be
#     a command format like: function(string input) > output.
#
# Examples:
#     input=('abc' 'DeF' '012')
#     func::array_map input INPLACE func::strtoupper
#     echo "${input[@]}" # => ABC DEF 012
#
#     sub::print $'def,abc,ghi\n1,3,2,5,4' | \
#         IFS=',' stream::array_map ARRAY func::sort
#         # => abc,def,ghi\n1,2,3,4,5
#
#     sub::print $'abcbd\nbcdbcb' | \
#         stream::array_map INPLACE func::str_replace 'bc' 'BC'
#         # => aBCbd\nBCdBCb
func::array_map() {
  if [ "$#" -ge 3 ]; then
    if sub::array_is_empty "${1}"; then return; fi
    local __array_map_variable="${1}"; shift
    local __array_map_type="${1}"; shift
    local __array_map_callback="${1}"; shift

    local __array_map_keys=()
    local __array_map_key=''
    func::array_keys __array_map_keys "${__array_map_variable}"
    case "${__array_map_type}" in
      'ARRAY')
        local __array_map_value=''
        local __array_map_array_value=()
        for __array_map_key in "${__array_map_keys[@]}"; do
          func::strcpy __array_map_value \
                       "${__array_map_variable}[${__array_map_key}]"
          func::array __array_map_array_value "${__array_map_value}"
          "${__array_map_callback}" __array_map_array_value "$@"
          func::let "${__array_map_variable}[${__array_map_key}]" \
                    "${__array_map_array_value[*]}"
        done
        ;;
      'FUNCTION')
        local __array_map_value=''
        for __array_map_key in "${__array_map_keys[@]}"; do
          func::strcpy __array_map_value \
                       "${__array_map_variable}[${__array_map_key}]"
          "${__array_map_callback}" \
              "${__array_map_variable}[${__array_map_key}]" \
              "${__array_map_value}" "$@"
        done
        ;;
      'INPLACE')
        local __array_map_value=''
        for __array_map_key in "${__array_map_keys[@]}"; do
          "${__array_map_callback}" \
              "${__array_map_variable}[${__array_map_key}]" "$@"
        done
        ;;
      'COMMAND')
        local __array_map_value=''
        local __array_map_tmpfile=''
        func::tmpfile __array_map_tmpfile
        for __array_map_key in "${__array_map_keys[@]}"; do
          func::strcpy __array_map_value \
                       "${__array_map_variable}[${__array_map_key}]"
          "${__array_map_callback}" \
              "${__array_map_value}" "$@" > "${__array_map_tmpfile}"
          func::file_get_contents \
              "${__array_map_variable}[${__array_map_key}]" \
              "${__array_map_tmpfile}"
        done
        ;;
      *)
        LOG ERROR "Unknown array_map type: ${__array_map_type}"
        return 2
        ;;
    esac
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::array_map() {
  if [ "$#" -ge 2 ]; then
    local __array_map_type="${1}"
    local LINE='' NEWLINE=''
    while func::readline; do
      local __array_map_line=("${LINE}")
      func::array_map __array_map_line "$@"
      if [ "${__array_map_type}" = 'COMMAND' ]; then
        sub::print "${__array_map_line[0]}"
      else
        sub::print "${__array_map_line[0]}${NEWLINE}"
      fi
    done
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# array_unique -- Removes duplicated elements from an array variable.
#
# array_unique sorts elements first and removes duplicated elements.  Function
# form applies array_unique to the given variable.  Stream form applies
# array_unique to every line.  Every line is treated as elements.
#
# Usage:
#     // 1. Function form.
#     void func::array_unique(string[]* variable)
#     // 2. Stream form.
#     void stream::array_unique() < input > output
#
# Examples:
#     a=(c b a b)
#     func::array_unique a
#     echo "${a[@]}"  # => a b c
#
#     echo c b a b | stream::array_unique  # => a b c
#
#     echo c,b,a,b | IFS=, stream::array_unique  # => a,b,c
func::array_unique() {
  if [ "$#" -eq 1 ]; then
    if sub::array_is_empty "${1}"; then return; fi
    local __array_unique_values=()
    func::array_values __array_unique_values "${1}"
    func::sort __array_unique_values
    local __array_unique_i="${#__array_unique_values[*]}"
    while (( __array_unique_i -= 1 )); do
      if [ "${__array_unique_values[$(( __array_unique_i - 1 ))]}" = \
           "${__array_unique_values[${__array_unique_i}]}" ]; then
        unset "__array_unique_values[${__array_unique_i}]"
      fi
    done
    func::array_values "${1}" __array_unique_values
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::array_unique() {
  if [ "$#" -eq 0 ]; then
    stream::array_map ARRAY func::array_unique
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# array_values -- Copies elements from an array to an array.
#
# array_values copies elements in an array variable into an array variable.
#
# Usage:
#     // 1. Function form.
#     void func::array_values(string[]* output, string[]* input)
#     // 2. Command form.
#     void sub::array_values(string[]* input) > output
func::array_values() {
  if [ "$#" -eq 2 ]; then
    if sub::array_is_empty "${2}"; then
      eval "${1}=()"
    else
      eval "${1}=(\"\${${2}[@]}\")"
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::array_values() {
  if [ "$#" -eq 1 ]; then
    local __array_values_values=()
    func::array_values __array_values_values "${1}"
    sub::implode __array_values_values
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# count -- Counts the number of elements.
#
# count counts the number of elements of an array.
#
# Usage:
#     // 1. Function form
#     void func::count(int* result, string[]* values)
#     // 2. Command form
#     void sub::count(string[]* values) > result
func::count() {
  if [ "$#" -eq 2 ]; then
    func::strcpy "${1}" "#${2}[*]"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::count() {
  if [ "$#" -eq 1 ]; then
    eval "sub::println \"\${#${1}[*]}\""
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# sort -- Sorts elements.
#
# sort sorts elements.  The function form sorts elements in a variable in place.
# The stream form applies sort to every line.  Every line is treated as
# elements.
#
# Usage:
#     // 1. Function form.
#     void func::sort(string[]* variable)
#     // 2. Stream form.
#     void stream::sort() < input > output
func::sort() {
  if [ "$#" -eq 1 ]; then
    local __sort_name="${1}"
    if eval "[ \"\${#${__sort_name}[*]}\" -lt 2 ]"; then return; fi
    local __sort_values=()
    func::array_values __sort_values "${__sort_name}"
    __func::quick_sort
    func::array_values "${__sort_name}" __sort_values
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::sort() {
  if [ "$#" -eq 0 ]; then
    stream::array_map ARRAY func::sort
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

__func::quick_sort() {
  local size="${#__sort_values[@]}"
  local pivot="${__sort_values[$(( size / 2 ))]}"
  local values1=() values2=() values3=()

  for value in "${__sort_values[@]}"; do
    if [ "${value}" \< "${pivot}" ]; then
      values1+=("${value}")
    elif [ "${value}" \> "${pivot}" ]; then
      values3+=("${value}")
    else
      values2+=("${value}")
    fi
  done
  func::sort values1
  func::sort values3
  __sort_values=()
  if ! sub::array_is_empty values1; then __sort_values+=("${values1[@]}"); fi
  if ! sub::array_is_empty values2; then __sort_values+=("${values2[@]}"); fi
  if ! sub::array_is_empty values3; then __sort_values+=("${values3[@]}"); fi
}

# date -- Format a local time/date.
#
# date formats a local time/date.
#
# Usage:
#     void func::date(string* output, string format, int time)
func::date() {
  if [ "$#" -eq 3 ]; then
    local __func_date_php="${2}"
    local __func_date_c=''
    local __func_date_buffer=''
    while [ "${__func_date_php}" != '' ]; do
      case "${__func_date_php}" in
        'd'*)
          __func_date_c+='%d'
          __func_date_php="${__func_date_php:1}"
          ;;
        'D'*)
          __func_date_c+='%a'
          __func_date_php="${__func_date_php:1}"
          ;;
        'j'*)
          __func_date_c+='%-d'
          __func_date_php="${__func_date_php:1}"
          ;;
        'l'*)
          __func_date_c+='%A'
          __func_date_php="${__func_date_php:1}"
          ;;
        'N'*)
          __func_date_c+='%u'
          __func_date_php="${__func_date_php:1}"
          ;;
        'w'*)
          __func_date_c+='%w'
          __func_date_php="${__func_date_php:1}"
          ;;
        'z'*)
          __func_date_c+='%-j'
          __func_date_php="${__func_date_php:1}"
          ;;
        'W'*)
          __func_date_c+='%W'
          __func_date_php="${__func_date_php:1}"
          ;;
        'F'*)
          __func_date_c+='%B'
          __func_date_php="${__func_date_php:1}"
          ;;
        'm'*)
          __func_date_c+='%m'
          __func_date_php="${__func_date_php:1}"
          ;;
        'M'*)
          __func_date_c+='%b'
          __func_date_php="${__func_date_php:1}"
          ;;
        'n'*)
          __func_date_c+='%-m'
          __func_date_php="${__func_date_php:1}"
          ;;
        'o'*)
          __func_date_c+='%G'
          __func_date_php="${__func_date_php:1}"
          ;;
        'Y'*)
          __func_date_c+='%Y'
          __func_date_php="${__func_date_php:1}"
          ;;
        'y'*)
          __func_date_c+='%y'
          __func_date_php="${__func_date_php:1}"
          ;;
        'a'*)
          __func::date __func_date_buffer '%p' "${3}"
          func::strtoupper __func_date_buffer
          __func_date_c+="${__func_date_buffer}"
          __func_date_php="${__func_date_php:1}"
          ;;
        'A'*)
          __func_date_c+='%p'
          __func_date_php="${__func_date_php:1}"
          ;;
        'g'*)
          __func_date_c+='%-I'
          __func_date_php="${__func_date_php:1}"
          ;;
        'G'*)
          __func_date_c+='%-H'
          __func_date_php="${__func_date_php:1}"
          ;;
        'h'*)
          __func_date_c+='%I'
          __func_date_php="${__func_date_php:1}"
          ;;
        'H'*)
          __func_date_c+='%H'
          __func_date_php="${__func_date_php:1}"
          ;;
        'i'*)
          __func_date_c+='%M'
          __func_date_php="${__func_date_php:1}"
          ;;
        's'*)
          __func_date_c+='%S'
          __func_date_php="${__func_date_php:1}"
          ;;
        'e'*|'T'*)
          __func_date_c+='%Z'
          __func_date_php="${__func_date_php:1}"
          ;;
        'O'*)
          __func_date_c+='%z'
          __func_date_php="${__func_date_php:1}"
          ;;
        'P'*)
          __func::date __func_date_buffer '%z' "${3}"
          __func_date_c+="${__func_date_buffer:0:3}:${__func_date_buffer:3}"
          __func_date_php="${__func_date_php:1}"
          ;;
        'c'*)
          __func_date_c+='%Y-%m-%dT%H:%M:%S'
          __func::date __func_date_buffer '%z' "${3}"
          __func_date_c+="${__func_date_buffer:0:3}:${__func_date_buffer:3}"
          __func_date_php="${__func_date_php:1}"
          ;;
        'r'*)
          __func_date_c+='%a, %d %b %Y %T %z'
          __func_date_php="${__func_date_php:1}"
          ;;
        'U'*)
          __func_date_c+='%s'
          __func_date_php="${__func_date_php:1}"
          ;;
        '\%'*|'%'*)
          __func_date_c+='%%'
          __func_date_php="${__func_date_php:1}"
          ;;
        '\'*)
          __func_date_c+="${__func_date_php:1:1}"
          __func_date_php="${__func_date_php:2}"
          ;;
        *)
          __func_date_c+="${__func_date_php:0:1}"
          __func_date_php="${__func_date_php:1}"
          ;;
      esac
    done
    __func::date "${1}" "${__func_date_c}" "${3}"
  elif [ "$#" -eq 2 ]; then
    func::date "$@" "$(date +'%s')"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::date() {
  if [ "$#" -eq 1 -o "$#" -eq 2 ]; then
    local __sub_date_result=''
    func::date __sub_date_result "$@"
    sub::println "${__sub_date_result}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

__func::date() {
  if [ "$#" -eq 3 ]; then
    if [ "${UNAME}" = 'Linux' ]; then
      func::let "${1}" "$(LC_ALL=C date --date="@${3}" "+${2}")"
    else
      func::let "${1}" "$(LC_ALL=C date -j -f '@%s' "@${3}" "+${2}")"
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# strtotime -- Parses a datetime text into a UNIX timestamp.
#
# strtotime parses a datetime text into a UNIX timestamp.
#
# Usage:
#     void func::strtotime(int* time, string time_text)
func::strtotime() {
  if [ "$#" -eq 2 ]; then
    local __func_strtotime_match=()
    local __func_strtotime_text=''
    local __func_strtotime_timezone=''
    local __func_strtotime_format=''
    # 2006-01-02
    if sub::ereg_match '^([0-9]{4})[-/:]?([0-9]{2})[-/:]?([0-9]{2})$' \
        "${2}" __func_strtotime_match; then
      __func_strtotime_text+="${__func_strtotime_match[1]}"
      __func_strtotime_text+="-${__func_strtotime_match[2]}"
      __func_strtotime_text+="-${__func_strtotime_match[3]}"
      __func_strtotime_text+=' 00:00:00'
      __func::strtotime "${1}" "${__func_strtotime_text}" '%Y-%m-%d %H:%M:%S'
      return
    fi
    # 02/Jan/2006 (Common logfile format)
    if sub::ereg_match \
        '^([0-9]+)[/ \-]+([A-Z][a-z][a-z])[/ \-]+([0-9]{4})$' \
        "${2}" __func_strtotime_match; then
      func::exec __func_strtotime_text printf '%02d %s %04d 00:00:00' \
          "${__func_strtotime_match[1]}" \
          "${__func_strtotime_match[2]}" \
          "${__func_strtotime_match[3]}"
      __func::strtotime "${1}" "${__func_strtotime_text}" '%d %b %Y %H:%M:%S'
      return
    fi
    # 02-Jan-06 (Old RFC850 HTTP format)
    if sub::ereg_match \
        '^([0-9]+)[/ \-]+([A-Z][a-z][a-z])[/ \-]+([0-9]{2})$' \
        "${2}" __func_strtotime_match; then
      func::exec __func_strtotime_text printf '%02d %s %02d 00:00:00' \
          "${__func_strtotime_match[1]}" \
          "${__func_strtotime_match[2]}" \
          "${__func_strtotime_match[3]}"
      __func::strtotime "${1}" "${__func_strtotime_text}" '%d %b %y %H:%M:%S'
      return
    fi
    # Jan 2 2006 (Unix ls format)
    if sub::ereg_match \
        '^([A-Z][a-z][a-z])[/ \-]+([0-9]+)[,/ \-]+([0-9]{4})$' \
        "${2}" __func_strtotime_match; then
      func::exec __func_strtotime_text printf '%02d %s %04d 00:00:00' \
          "${__func_strtotime_match[2]}" \
          "${__func_strtotime_match[1]}" \
          "${__func_strtotime_match[3]}"
      __func::strtotime "${1}" "${__func_strtotime_text}" '%d %b %Y %H:%M:%S'
      return
    fi
    # @1136214245 (Unix timestamp)
    if sub::ereg_match '^@?(-?[0-9]{1,10})$' "${2}" __func_strtotime_match; then
      __func::strtotime "${1}" "@${__func_strtotime_match[1]}" '@%s'
      return
    fi
    # 2006-01-02 15:04:05 (MySQL)
    # 2006/01/02 15:04:05 (Regular format)
    # 2006:01:02 15:04:05 (EXIF)
    # 2006-01-02T15:04:05
    if sub::ereg_match \
        '^([0-9]{4})[-/:]?([0-9]{2})[-/:]?([0-9]{2})[ T]?([0-9]{2})[:\-]?([0-9]{2})[:\-]?([0-9]{2}) *([A-Za-z0-9\-\+ /]+)?$' \
        "${2}" __func_strtotime_match; then
      __func_strtotime_text+="${__func_strtotime_match[1]}"
      __func_strtotime_text+="-${__func_strtotime_match[2]}"
      __func_strtotime_text+="-${__func_strtotime_match[3]}"
      __func_strtotime_text+=" ${__func_strtotime_match[4]}"
      __func_strtotime_text+=":${__func_strtotime_match[5]}"
      __func_strtotime_text+=":${__func_strtotime_match[6]}"
      __func_strtotime_timezone+="${__func_strtotime_match[7]}"
      __func_strtotime_format='%Y-%m-%d %H:%M:%S'
    # Mon, 02 Jan 2006 15:04:05 GMT (HTTP format)
    elif sub::ereg_match \
        '^([A-Z][a-z]+, +)?([0-9]+)[/ \-]+([A-Z][a-z][a-z])[/ \-]+([0-9]{2}|[0-9]{4})[ :T]([0-9]{2})[:\-]([0-9]{2})[:\-]([0-9]{2}) *([A-Z][A-Za-z0-9\-\+ /]+)?([\-\+][0-9]{4})?$' \
        "${2}" __func_strtotime_match; then
      if [ "${#__func_strtotime_match[4]}" -eq 2 ]; then
        if [ "${__func_strtotime_match[4]}" -lt 70 ]; then
          __func_strtotime_match[4]="20${__func_strtotime_match[4]}"
        else
          __func_strtotime_match[4]="19${__func_strtotime_match[4]}"
        fi
      fi
      func::exec __func_strtotime_text printf '%02d %s %04d %02d:%02d:%02d' \
          "${__func_strtotime_match[2]}" \
          "${__func_strtotime_match[3]}" \
          "${__func_strtotime_match[4]}" \
          "${__func_strtotime_match[5]}" \
          "${__func_strtotime_match[6]}" \
          "${__func_strtotime_match[7]}"
      __func_strtotime_timezone+="${__func_strtotime_match[8]}"
      __func_strtotime_timezone+="${__func_strtotime_match[9]}"
      __func_strtotime_format='%d %b %Y %H:%M:%S'
    else
      LOG ERROR "Unkown date format: ${2}"
      return 1
    fi
    case "${__func_strtotime_timezone}" in
      'Z')   __func_strtotime_timezone='+0000';;
      'JST') __func_strtotime_timezone='+0900';;
    esac
    if [ "${__func_strtotime_timezone}" != '' ]; then
      if sub::ereg_match '^[\-\+][0-9]{4}$' \
                         "${__func_strtotime_timezone}"; then
        __func::strtotime \
            "${1}" "${__func_strtotime_text} ${__func_strtotime_timezone}" \
            "${__func_strtotime_format} %z"
      else
        TZ="${__func_strtotime_timezone}" \
            __func::strtotime \
            "${1}" "${__func_strtotime_text}" "${__func_strtotime_format}"
      fi
    else
      __func::strtotime \
          "${1}" "${__func_strtotime_text}" "${__func_strtotime_format}"
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::strtotime() {
  if [ "$#" -eq 1 ]; then
    local __sub_strtotime=''
    func::strtotime __sub_strtotime "${1}"
    sub::println "${__sub_strtotime}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# void __func::strtotime(int* time, string input_time, string input_format)
__func::strtotime() {
  if [ "$#" -eq 3 ]; then
    if [ "${UNAME}" = 'Linux' ]; then
      func::let "${1}" "$(LC_ALL=C date --date="${2}" '+%s')"
    else
      func::let "${1}" "$(LC_ALL=C date -j -f "${3}" "${2}" '+%s')"
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# time -- Returns current Unix timestamp.
#
# time returns current Unix timestamp.
#
# Usage:
#     // 1. Function form.
#     void func::time(string* result)
#     // 2. Command form.
#     void sub::time() > output
func::time() {
  if [ "$#" -eq 1 ]; then
    sub::let "${1}" "$(date +'%s')"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::time() {
  if [ "$#" -eq 0 ]; then
    date +'%s'
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# fgets -- Gets a line from STDIN.
#
# fgets reads a line and regards it as a result.  fgets does not strip a
# trailing new line.  The function form sets the result to a variable.  The
# subroutine form outputs the result to the standard output.
#
# Usage:
#     // 1. Function form.
#     bool func::fgets(string* variable)
#     // 2. Subroutine form.
#     bool sub::fgets() > line
func::fgets() {
  if [ "$#" -eq 1 ]; then
    local __fgets_buffer=''
    local __fgets_line=''

    func::let "${1}" ''
    # Check if EOF.
    if ! IFS= read -r -n 1 -d '' __fgets_buffer; then
      return 1
    fi
    __fgets_line+="${__fgets_buffer}"
    if [ "${__fgets_buffer}" = $'\n' ]; then
      func::strcpy "${1}" __fgets_buffer
      return
    fi
    if IFS= read -r -d $'\n' __fgets_buffer; then
      __fgets_buffer+=$'\n'
    fi
    __fgets_line+="${__fgets_buffer}"
    func::strcpy "${1}" __fgets_line
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::fgets() {
  if [ "$#" -eq 0 ]; then
    local variable=''
    if ! func::fgets variable; then return 1; fi
    sub::print "${variable}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# file_get_contents -- Reads an entire file into a string.
#
# The function form reads an entire file and sets its contents to the
# variable.  The subroutine form reads an entire file and outputs its contents
# to the standard output.  The stream form reads a file name for each line and
# outputs its contents to the standard output.
#
# Usage:
#     // 1. Function form.
#     func::file_get_contents(string* variable, string filename)
#     // 2. Subroutine form.
#     sub::file_get_contents(string filename) > output
#     // 3. Stream form.
#     stream::file_get_contents() < input > output
#
# Examples:
#     sub::print hello > "${TMPDIR}/foo"
#     func::file_get_contents variable "${TMPDIR}/foo"
#     echo "${variable}"  # => hello
#
#     sub::print hello > "${TMPDIR}/foo"
#     sub::file_get_contents "${TMPDIR}/foo"  # => hello
#
#     sub::print hello > "${TMPDIR}/foo"
#     sub::print world > "${TMPDIR}/bar"
#     { echo "${TMPDIR}/foo"; echo "${TMPDIR}/bar"; } | \
#         stream::file_get_contents  # => helloworld
func::file_get_contents() {
  if [ "$#" -eq 2 ]; then
    IFS= read -r -d '' "${1}" < "${2}" || true
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::file_get_contents() {
  if [ "$#" -eq 1 ]; then
    cat < "${1}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::file_get_contents() {
  if [ "$#" -eq 0 ]; then
    stream::array_map COMMAND cat
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# readarray -- Reads a line as an array.
#
# readarray reads a line and sets its content to LINE and its trailing new line
# to NEWLINE.
#
# Usage:
#     void func::readarray() < input
func::readarray() {
  if [ "$#" -eq 0 ]; then
    NEWLINE=''
    LINE=''
    if ! func::readline; then
      LINE=()
      return 1
    fi
    func::array LINE "${LINE}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# readline -- Gets a line.
#
# readline reads a line and sets its content to LINE and its trailing new line
# to NEWLINE.
#
# Usage:
#     void func::readline() < input
func::readline() {
  if [ "$#" -eq 0 ]; then
    local line=''
    NEWLINE=''
    LINE=''
    if ! func::fgets line; then
      return 1
    fi
    if [ "${line:$((${#line} - 2))}" = $'\r\n' ]; then
      NEWLINE=$'\r\n'
      LINE="${line%$'\r\n'}"
    elif [ "${line:$((${#line} - 1))}" = $'\n' ]; then
      NEWLINE=$'\n'
      LINE="${line%$'\n'}"
    else
      NEWLINE=''
      LINE="${line}"
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# tmpfile -- Creates a temporary file.
#
# tmpfile creates a temporary file with a unique name under ${TMPDIR}.
#
# Usage:
#     // 1. Function form.
#     void func::tmpfile(string* path)
#     // 2. Command form.
#     void sub::tmpfile() > path
func::tmpfile() {
  if [ "$#" -eq 1 ]; then
    func::let "${1}" \
        "${TMPDIR}/tmpfile.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::tmpfile() {
  if [ "$#" -eq 0 ]; then
    local tmpfile=''
    func::tmpfile tmpfile
    sub::println "${tmpfile}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# ereg_match -- Checks if a string matches an EREG pattern.
#
# ereg_match checks if a string matches an EREG pattern.
#
# Usage:
#     // 1. Command form.
#     bool sub::ereg_match(string pattern, string subject)
sub::ereg_match() {
  if [ "$#" -eq 2 ]; then
    if [[ "${2}" =~ $1 ]]; then
      return 0
    else
      return 1
    fi
  elif [ "$#" -eq 3 ]; then
    if [[ "${2}" =~ $1 ]]; then
      func::array_values "${3}" BASH_REMATCH
      return 0
    else
      return 1
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# greg_match -- Checks if a string matches a GREG pattern.
#
# greg_match checks if a string matches a GREG pattern.
#
# Usage:
#     // 1. Command form.
#     bool sub::greg_match(string pattern, string subject)
sub::greg_match() {
  if ! shopt extglob > /dev/null; then
    shopt -s extglob
    local __greg_match_result=0
    sub::greg_match "$@" || __greg_match_result="$?"
    shopt -u extglob
    return "${__greg_match_result}"
  elif [ "$#" -eq 2 ]; then
    [[ "${2}" = ${1} ]] || return 1
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# greg_replace -- Replace a GREG pattern with a string.
#
# greg_replace replaces substrings matching a pattern with a string.
#
# Usage:
#     // 1. Function form.
#     void func::greg_replace(string* subject, string pattern, string replace)
#     // 2. Command form.
#     void sub::greg_replace(
#         string subject, string pattern, string replace) > output
func::greg_replace() {
  if ! shopt extglob >/dev/null; then
    local __greg_replace_status=0
    shopt -s extglob
    func::greg_replace "$@"
    shopt -u extglob
  elif [ "$#" -eq 3 ]; then
    eval "${1}=\"\${${1}//\${2}/\${3}}\""
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::greg_replace() {
  if [ "$#" -eq 3 ]; then
    local __greg_replace_subject="${1}"
    func::greg_replace __greg_replace_subject "${2}" "${3}"
    sub::println "${__greg_replace_subject}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# greg_split -- Splits a string with a GREG pattern.
#
# greg_split splits a string with a GREG pattern.
#
# Usage:
#     // 1. Function form.
#     void func::greg_split(string[]* variable, string pattern, string value)
#     // 2. Command form.
#     void sub::greg_split(string pattern, string value)
#
# Caveat:
#   greg_split does not support \x02 for value.
func::greg_split() {
  if [ "$#" -eq 3 ]; then
    local __greg_split_value="${3}"
    func::greg_replace __greg_split_value "${2}" $'\x02'
    func::explode "${1}" $'\x02' "${__greg_split_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::greg_split() {
  if [ "$#" -eq 2 ]; then
    local __greg_split_variable=()
    func::greg_split __greg_split_variable "${1}" "${2}"
    sub::implode __greg_split_variable
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# getchildpids -- Gets child process IDs.
#
# Usage:
#     // 1. Function form.
#     void func::getchildpids(int[]* variable)
#     // 2. Command form.
#     void sub::getchildpids() > output
func::getchildpids() {
  if [ "$#" -eq 1 ]; then
    local __getchildpids_mypid=''
    func::getmypid __getchildpids_mypid
    local __getchildpids_pid='' __getchildpids_ppid=''
    local __getchildpids_result=()
    while IFS=$' \t\n' \
          read -r -d $'\n' __getchildpids_ppid __getchildpids_pid; do
      if [ "${__getchildpids_ppid}" = "${__getchildpids_mypid}" ]; then
        __getchildpids_result+=("${__getchildpids_pid}")
      fi
    done < <(ps -o ppid,pid)
    func::array_values "${1}" __getchildpids_result
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::getchildpids() {
  if [ "$#" -eq 0 ]; then
    local __getchildpids_variable=()
    func::getchildpids __getchildpids_variable
    sub::implode __getchildpids_variable
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# getmypid -- Gets the current process ID.
#
# Usage:
#     // 1. Function form.
#     void func::getmypid(int* variable)
#     // 2. Command form.
#     void sub::getmypid() > output
func::getmypid() {
  if [ "$#" -eq 1 ]; then
    if sub::isset BASHPID; then
      func::let "${1}" "${BASHPID}"
    else
      local __getmypid_pid_file=''
      func::tmpfile __getmypid_pid_file
      "${SHELL}" -c 'echo "${PPID}"' > "${__getmypid_pid_file}"
      read -r -d $'\n' "${1}" < "${__getmypid_pid_file}"
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::getmypid() {
  if [ "$#" -eq 0 ]; then
    local __getmypid_variable
    func::getmypid __getmypid_variable
    sub::println "${__getmypid_variable}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# is_main -- Returns 0 iff caller is in the main script.
#
# Usage:
#     // 1. Command form.
#     void sub::is_main()
sub::is_main() {
  if [ "$#" -eq 0 ]; then
    local __is_main_depth="${#BASH_SOURCE[*]}"
    if [ "${BASH_SOURCE[1]}" = \
         "${BASH_SOURCE[$((__is_main_depth - 1))]}" ]; then
      return 0
    else
      return 1
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# CHECK -- checks if a command succeeds.
#
# CHECK fails with a fatal error if a command fails.
#
# Usage:
#     void CHECK(string command...)
CHECK() {
  IFS=' ' eval 'local __CHECK_message="Check failure: $*"'
  if [ "$#" -ge 1 ] && [ "${1:0:10}" = '--message=' ]; then
    __CHECK_message="${1:10}"
    shift
  fi

  if [ "$#" -ge 1 ]; then
    local __CHECK_invert="${1}"

    if [ "${__CHECK_invert}" = '!' ]; then
      shift
      if "$@"; then
        LOG ERROR 'Check failure: !' "$@"
        LOG FATAL "${__CHECK_message}"
      fi
    else
      if ! "$@"; then
        LOG ERROR 'Check failure:' "$@"
        LOG FATAL "${__CHECK_message}"
      fi
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# DEPRECATED -- Declares as deprecated.
#
# DEPRECATED displays an error message and a stack trace.
#
# Usage:
#     void DEPRECATED()
DEPRECATED() {
  if [ "$#" -eq 0 ]; then
    LOG ERROR "$(imosh::stack_trace 'This is deprecated.' 2>&1)"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# LOG -- Logs a message.
#
# LOG logs a message with a timestamp, the current process ID and a file
# position.
#
# Usage:
#     void LOG(string log_level, string message...)
LOG() {
  if [ "$#" -ge 2 ]; then
    local log_level="${1}"; shift
    local log_level_id=0
    func::log_level log_level_id "${log_level}"
    if (( log_level_id < 1 || 4 < log_level_id )); then
      LOG FATAL "Invalid log_level for LOG: ${log_level}(${log_level_id})"
    fi
    # Do not use FLAGS_* variables directly because LOG may be called before
    # flag initialization.
    local logtostderr=0
    if sub::isset FLAGS_logtostderr; then
      logtostderr="${FLAGS_logtostderr}"
    fi
    local alsologtostderr=0
    if sub::isset FLAGS_alsologtostderr; then
      alsologtostderr="${FLAGS_alsologtostderr}"
    fi
    # Speed up by skipping message generation if it is not necessary.
    if ! sub::isset __IMOSH_LOGGING &&
       (( log_level_id < 3 && logtostderr == 0 && alsologtostderr == 0 )); then
      return
    fi
    local datetime="$(date +'%m%d %T.%N')"
    # For systems not supporting %N in date.
    datetime="${datetime/.N/.000000}"
    datetime="${datetime:0:20}"
    local pid
    if sub::isset __IMOSH_LOG_PID; then
      pid="${__IMOSH_LOG_PID}"
    else
      func::getmypid pid
    fi
    local file="${BASH_SOURCE[1]##*/}"
    if [ "${file}" = '' ]; then file='-'; fi
    local message_parameters=(
        "${log_level:0:1}${datetime}"
        "${pid}"
        "${file}:${BASH_LINENO[0]}]"
        "$@")
    IFS=' ' eval 'local message="${message_parameters[*]}"'
    local stacktrace_thoreshold=4
    if sub::isset FLAGS_stacktrace_threshold; then
      func::log_level __IMOSH_LOGGING_STACKTRACE \
                      "${FLAGS_stacktrace_threshold}"
    fi
    if (( stacktrace_thoreshold <= log_level_id )); then
      message+=$'\n'
      message+="$(
          imosh::stack_trace "*** LOG ${log_level} stack trace ***" 2>&1)"
    fi
    case "${log_level}" in
      'INFO')
        if (( logtostderr || alsologtostderr )); then
          echo "${message}" >&105
        fi
        if (( ! logtostderr )); then
          echo "${message}" >&101
        fi
        ;;
      'WARNING')
        if (( logtostderr || alsologtostderr )); then
          echo "${message}" >&105
        fi
        if (( ! logtostderr )); then
          echo "${message}" >&101
          echo "${message}" >&102
        fi
        ;;
      'ERROR')
        echo "${message}" >&105
        if (( ! logtostderr )); then
          echo "${message}" >&101
          echo "${message}" >&102
          echo "${message}" >&103
        fi
        ;;
      'FATAL')
        echo "${message}" >&105
        if (( ! logtostderr )); then
          echo "${message}" >&101
          echo "${message}" >&102
          echo "${message}" >&103
          echo "${message}" >&104
        fi
        sub::exit 1
        ;;
    esac
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

func::log_level() {
  if [ "$#" -eq 2 ]; then
    case "${2}" in
      'ALL')     func::let "${1}" 0;;
      'INFO')    func::let "${1}" 1;;
      'WARNING') func::let "${1}" 2;;
      'ERROR')   func::let "${1}" 3;;
      'FATAL')   func::let "${1}" 4;;
      'NONE')    func::let "${1}" 5;;
      *)         LOG FATAL "Unknown log level: ${2}";;
    esac
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

__imosh::logging::open() {
  if [ "$#" -eq 2 ]; then
    local target="${FLAGS_log_dir}/${__IMOSH_LOG_PREFIX}.${1}.${__IMOSH_LOG_SUFFIX}"
    eval "exec ${2}> \"\${target}\""
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

imosh::logging::init() {
  if [ "$#" -eq 0 ]; then
    # Close descriptors for logs beforehand for BASH3's bug.
    exec 101>&- 102>&- 103>&- 104>&-
    if [ "${FLAGS_log_dir}" != '' ]; then
      if [ -w "${FLAGS_log_dir}" ]; then
        __IMOSH_LOG_PREFIX="${0##*/}.$(hostname -s).$(whoami)"
        __IMOSH_LOG_SUFFIX="$(date +'%Y%m%d.%H%M%S').$$"
        __imosh::logging::open INFO    101
        __imosh::logging::open WARNING 102
        __imosh::logging::open ERROR   103
        __imosh::logging::open FATAL   104
        __IMOSH_LOGGING=1
        return
      else
        LOG ERROR "Failed to open files to write logs: ${FLAGS_log_dir}"
      fi
    fi
    exec 101>'/dev/null' 102>'/dev/null' 103>'/dev/null' 104>'/dev/null'
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# rand -- Generates a random integer.
#
# rand generates a random integer.
#
# Usage:
#     // 1. Function form.
#     void func::rand(int* variable, int minimum, int maximum)
#     void func::rand(int* variable, int maximum)
#     void func::rand(int* variable)
#     // 2. Command form.
#     void sub::rand(int minimum, int maximum) > output
#     void sub::rand(int maximum) > output
#     void sub::rand() > output
func::rand() {
  if [ "$#" -eq 3 ]; then
    local __rand_value=0
    __func::rand "${2}" "${3}"
    func::let "${1}" "${__rand_value}"
  elif [ "$#" -eq 2 ]; then
    func::rand "${1}" 0 "${2}"
  elif [ "$#" -eq 1 ]; then
    func::rand "${1}" 2147483647
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::rand() {
  if [ "$#" -le 2 ]; then
    local __rand_variable=0
    func::rand __rand_variable "$@"
    sub::println "${__rand_variable}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

__func::rand() {
  local min="${1}" max="${2}" range=0
  if [ "${min}" -eq "${max}" ]; then
    __rand_value="${min}"
    return
  elif [ "${min}" -gt "${max}" ]; then
    local min="${max}" max="${min}"
  fi
  (( __rand_value = RANDOM ^ (RANDOM << 8) ^ (RANDOM << 16) ^ (RANDOM << 24) ^
         (RANDOM << 32) ^ (RANDOM << 40) ^ (RANDOM << 48) ^ (RANDOM << 56),
     range = max - min + 1,
     __rand_value = min + (__rand_value % range + range) % range )) || true
}

# atexit -- Registers a function on shutdown.
#
# atexit registers a function to be excuted on shutdown.
#
# Usage:
#     // 1. Command form.
#     void sub::atexit(string command)
sub::atexit() {
  if [ "$#" -eq 1 ]; then
    sub::println "${1}" >> "${__IMOSH_CORE_TMPDIR}/atexit.sh"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# exec -- Executes an external program.
#
# func::exec executes an external program and sets its output to the variable.
#
# Usage:
#     // Function form.
#     void func::exec(string* output, string arguments...)
func::exec() {
  if [ "$#" -gt 1 ]; then
    local __func_exec_variable="${1}"
    shift
    local __func_exec_output=''
    func::tmpfile __func_exec_output
    "$@" >"${__func_exec_output}"
    func::file_get_contents "${__func_exec_variable}" "${__func_exec_output}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# exit, die -- Kills the current script.
#
# sub::exit kills all the subprocesses of the current program.  If an integer
# argument is given, sub::exit exits with the status.  Otherwise, sub::exit
# shows the given message and exits with status 0.  sub::die shows a stack
# trace and delegates arguments to sub::exit.
#
# Usage:
#     // 1-a. Command form with a message.
#     void sub::exit(string message)
#     // 1-b. Command form with a status.
#     void sub::exit(int status = 0)
#     // 1-c. Command form with a message.
#     void sub::die(string message)
#     // 1-d. Command form with a status.
#     void sub::die(int status = 0)
sub::exit() {
  if [ "$#" -eq 1 ]; then
    local status=0
    if [[ "${1}" =~ ^[0-9]+$ ]]; then
      status="${1}"
    else
      local message="${1}"
      func::rtrim message
      sub::println "${message}"
    fi
    sub::print "${status}" > "${__IMOSH_CORE_TMPDIR}/EXIT"
    # First, kill all the childs of the current process so that no child
    # processes spawn new processes.
    __sub::exit
    # Then, try to kill other processes under the root process except this
    # process.
    __sub::exit "${IMOSH_ROOT_PID}"
    # Send a TERM signal to the root process.
    kill -TERM "${IMOSH_ROOT_PID}" 2> '/dev/null' || true
    # If this is the root process, following commands will not be executed.
    # Exit immediately if this is the root process.
    exit "${status}"
  elif [ "$#" -eq 0 ]; then
    sub::exit 0
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::die() {
  imosh::stack_trace "*** imosh::die stack trace: ***"
  sub::exit "$@"
}

# __sub::exit -- Kills subprocesses.
#
# __sub::exit kills pid's subprocesses.
#
# Usage:
#     void __sub::exit::kill(int pid = $$, int caller_pid = $$)
__sub::exit() {
  if [ "$#" -eq 2 ]; then
    if [ "${1}" != "${2}" -a "${1}" != "${IMOSH_ROOT_PID}" ]; then
      kill -STOP "${1}" 2>/dev/null || true
    fi
    local tmpfile=''
    local ppid=0
    local pid=0
    func::tmpfile tmpfile
    ps -o ppid,pid > "${tmpfile}"
    while IFS=$' \t\n' read -r ppid pid; do
      if [ "${ppid}" = "${1}" ]; then
        __sub::exit "${pid}" "${2}"
      fi
    done < "${tmpfile}"
    if [ "${1}" != "${2}" -a "${1}" != "${IMOSH_ROOT_PID}" ]; then
      kill -KILL "${1}" 2>/dev/null || true
    fi
  elif [ "$#" -eq 1 ]; then
    local pid=0
    func::getmypid pid
    __sub::exit "${1}" "${pid}"
  elif [ "$#" -eq 0 ]; then
    local pid=0
    func::getmypid pid
    __sub::exit "${pid}" "${pid}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# throttle -- Throttles by the number of child processes.
#
# throttle waits that the number of the child processes is less than a limit.
# Firstly, throttle waits for 0.1 second, and the n-th retry (n < 10) waits for
# n * 0.1 seconds.  The n-th retry (n >= 10) waits for 1 second.
#
# Usage:
#     void sub::throttle(int limit)
sub::throttle() {
  if [ "$#" -eq 1 ]; then
    local pids=()
    local sleep=0

    while :; do
      func::getchildpids pids
      if [ "${#pids[*]}" -lt "${1}" ]; then
        break
      fi
      if (( sleep += 1, sleep < 10 )); then
        sleep "0.${sleep}"
      else
        sleep 1
      fi
    done
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# usage -- Shows a usage message.
#
# usage shows a usage message based on a header comment.  A header comment
# consists of consecutive comment lines.  Comment lines starting with "#!" are
# ignored.
#
# Usage:
#     void sub::usage(string file) > output
#
# Options:
# - --format=text
#       Select one fromat from text/markdown/groff.
# - --title=true
#       Treat the first line as title.
# - --markdown_heading=''
#       Prepend a string to every heading.
sub::usage() {
  local ARGS_format='text' ARGS_title=1 ARGS_markdown_heading=''
  eval "${IMOSH_PARSE_ARGUMENTS}"

  if [ "$#" -eq 1 ]; then
    local usage='' line='' first_line="${ARGS_title}" is_buffered=0
    while IFS= read -r line; do
      case "${line}" in
        '#!'*) continue;;
        '# '*) usage+="${line:2}"$'\n';;
        '#'*)  usage+="${line:1}"$'\n';;
        *)     break;;
      esac
    done < "${1}"
    func::trim usage
    [ "${usage}" != '' ] || return
    if [ "${ARGS_format}" = 'text' ]; then
      sub::print "${usage}"$'\n\n'
      return
    fi
    while :; do
      (( is_buffered )) || IFS= read -r line || break
      is_buffered=0
      func::rtrim line
      # Show title.
      if (( first_line )); then
        case "${ARGS_format}" in
          'groff')    sub::println ".TH ${line} 1";;
          'markdown') sub::println "${ARGS_markdown_heading} ${line}";;
        esac
        first_line=0
      # Show section title.
      elif sub::greg_match '*:' "${line}"; then
        local title="${line%:}"
        func::strtoupper title
        case "${ARGS_format}" in
          'groff')    sub::println ".SH ${title}";;
          'markdown') sub::println "${ARGS_markdown_heading}# ${line%:}";;
        esac
      # Show code.
      elif [ "${line:0:4}" = '    ' ]; then
        case "${ARGS_format}" in
          'groff')    sub::println '.Bd -literal -offset indent';;
          'markdown') sub::println '```sh';;
        esac
        while [ "${line:0:4}" = '    ' ]; do
          case "${ARGS_format}" in
            'groff')    sub::println "${line#'    '}";;
            'markdown') sub::println "${line#'    '}";;
          esac
          IFS= read -r line || break
        done
        case "${ARGS_format}" in
          'groff')    sub::println '.Ed';;
          'markdown') sub::print $'```\n\n';;
        esac
        is_buffered=1
      # Show an item.
      elif sub::greg_match '*( )- *' "${line}"; then
        func::ltrim line
        CHECK [ "${line:0:2}" = '- ' ]
        line="${line:2}"
        case "${ARGS_format}" in
          'groff')    sub::println $'.TP\n'".B ${line}";;
          'markdown') sub::println "* ${line}";;
        esac
        local markdown_indent='    * '
        while IFS= read -r line; do
          if sub::greg_match '*( )- *' "${line}" || \
             sub::greg_match '*([[:space:]])' "${line}"; then
            break
          fi
          func::ltrim line
          case "${ARGS_format}" in
            'groff')    sub::println "${line}";;
            'markdown') sub::println "${markdown_indent}${line}"
                        markdown_indent='      ';;
          esac
        done
        is_buffered=1
      else
        sub::println "${line}"
      fi
    done <<<"${usage}"
    sub::println
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# addslashes -- Quotes a string with backslahses.
#
# Quotes string with backslashes. Single quote, double quote and backslash in
# subject are escaped.
#
# Usage:
#     // 1. Function form.
#     void func::addslashes(string* subject)
func::addslashes() {
  if [ "$#" -eq 1 ]; then
    func::str_replace "${1}" '\' '\\'
    func::str_replace "${1}" "'" "\\'"
    func::str_replace "${1}" '"' '\"'
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# base64_decode -- Decodes data with MIME base64.
#
# Usage:
#     // 1. Function form.
#     void func::base64_decode(string* variable, string data)
#     // 2. Command form.
#     void sub::base64_decode(string data) > output
#     // 3. Stream form.
#     void stream::base64_decode() < input > output
func::base64_decode() {
  if [ "$#" -eq 2 ]; then
    local __base64_decode_file=''
    func::tmpfile __base64_decode_file
    sub::print "${2}" | stream::base64_decode >"${__base64_decode_file}"
    func::file_get_contents "${1}" "${__base64_decode_file}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::base64_decode() {
  if [ "$#" -eq 1 ]; then
    sub::print "${1}" | stream::base64_decode
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::base64_decode() {
  if [ "$#" -eq 0 ]; then
    local __base64_decode_file=''
    func::tmpfile __base64_decode_file
    tr -cd '[:alnum:]/+' >"${__base64_decode_file}"
    wc -c <"${__base64_decode_file}" >"${__base64_decode_file}.count"
    local __base64_decode_count=0
    func::file_get_contents \
        __base64_decode_count "${__base64_decode_file}.count"
    local __base64_decode_suffix='===='
    sub::print "${__base64_decode_suffix:0:$(( 3 - (__base64_decode_count + 3) % 4 ))}" >>"${__base64_decode_file}"
    base64 --decode -i "${__base64_decode_file}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# base64_encode -- Encodes data with MIME base64.
#
# Usage:
#     // 1. Function form.
#     void func::base64_encode(string* variable, string data)
#     // 2. Command form.
#     void sub::base64_encode(string data) > output
#     // 3. Stream form.
#     void stream::base64_encode() < input > output
func::base64_encode() {
  if [ "$#" -eq 2 ]; then
    local __base64_encode_file=''
    func::tmpfile __base64_encode_file
    sub::print "${2}" | stream::base64_encode > "${__base64_encode_file}"
    func::file_get_contents "${1}" "${__base64_encode_file}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::base64_encode() {
  if [ "$#" -eq 1 ]; then
    sub::print "${1}" | stream::base64_encode
    sub::println
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::base64_encode() {
  if [ "$#" -eq 0 ]; then
    # Remove newlines for compatibility.
    openssl enc -e -base64 | tr -cd '[:print:]'
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# bin2hex -- Converts a binary string into hexadecimal representation.
#
# Converts binary data into hexadecimal representation.
#
# Usage:
#     // 1. Function form.
#     void func::bin2hex(string* hexadecimal_output, string binary_input)
#     // 2. Command form.
#     void sub::bin2hex(string binary_input) > hexadecimal_output
#     // 3. Stream form.
#     void stream::bin2hex() < binary_input > hexadecimal_output
func::bin2hex() {
  if [ "$#" -eq 2 ]; then
    func::let "${1}" "$(sub::print "${2}" | stream::bin2hex)"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::bin2hex() {
  if [ "$#" -eq 1 ]; then
    stream::bin2hex <<<"${1}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::bin2hex() {
  if [ "$#" -eq 0 ]; then
    od -An -tx1 | tr -d ' \n'
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# escapeshellarg -- Escapes a variable as a shell argument.
#
# escapeshellarg escapes variable's content so as to use it as a shell argument.
#
# Usage:
#     // 1. Function form.
#     void func::escapeshellarg(string* variable)
func::escapeshellarg() {
  if [ "$#" -eq 1 ]; then
    local __escapeshellarg_value=''
    func::strcpy __escapeshellarg_value "${1}"
    func::str_replace __escapeshellarg_value "'" "'\\''"
    func::let "${1}" "'${__escapeshellarg_value}'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# explode -- Splits a string by a substring.
#
# Splits a string by string.
#
# Usage:
#     // 1. Function form.
#     void func::explode(string* variable, string delimiter, string value)
func::explode() {
  if [ "$#" -eq 3 ]; then
    local __explode_value="${3}"
    if [ "${2}" != $'\x02' ]; then
      func::str_replace __explode_value "${2}" $'\x02'
    fi
    local __explode_result=()
    local __explode_term=''
    while IFS= read -r -d $'\x02' __explode_term; do
      __explode_result+=("${__explode_term}")
    done <<<"${__explode_value}"$'\x02'
    func::array_values "${1}" __explode_result
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# hex2bin -- Decodes a hexadecimally encoded binary string.
#
# Decodes a hexadecimally encoded binary string.
#
# Usage:
#     // 1-a. Function form.
#     void func::hex2bin(string* output, string input)
#     // 1-b. Function form.
#     void func::hex2bin(string* variable)
#     // 2. Command form.
#     void sub::hex2bin(string input) > output
#     // 3. Stream form.
#     void stream::hex2bin() < input > output
func::hex2bin() {
  if [ "$#" -eq 2 ]; then
    local __hex2bin_result=''
    __func::hex2bin <<<"${2}"
    func::let "${1}" "${__hex2bin_result}"
  elif [ "$#" -eq 1 ]; then
    local __hex2bin_data=''
    func::strcpy __hex2bin_data "${1}"
    func::hex2bin "${1}" "${__hex2bin_data}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::hex2bin() {
  if [ "$#" -eq 1 ]; then
    stream::hex2bin <<<"${1}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::hex2bin() {
  if [ "$#" -eq 0 ]; then
    local __hex2bin_variable=''
    __func::hex2bin
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

__func::hex2bin() {
  local __hex2bin_char='' __hex2bin_buffer=''
  while read -n 1 __hex2bin_char; do
    case "${__hex2bin_char}" in
      [0-9a-fA-F]) __hex2bin_buffer+="${__hex2bin_char}";;
      *) continue;;
    esac
    if [ "${#__hex2bin_buffer}" -eq 2 ]; then
      if ! sub::isset __hex2bin_result; then
        printf "\\x${__hex2bin_buffer}"
      else
        eval "__hex2bin_result+=\$'\\x${__hex2bin_buffer}'"
      fi
      __hex2bin_buffer=''
    fi
  done
}

# implode -- Joins array elements with a string.
#
# func::implode joins `pieces` with `glue`.
# *Stream form* uses the IFS environment variable as an input separator and
# processes line by line.
#
# Usage:
#     // 1. Function form.
#     void func::implode(string* variable, string glue, string[]* pieces)
#     // 2. Command form.
#     void sub::implode(string glue, string[]* pieces) > result
#     void sub::implode(string[]* pieces) > result
#     // 3. Stream form.
#     void stream::implode(string glue) < input > output
#
# Aliases:
#   func::join, sub::join and stream::join are aliases of func::implode,
#   sub::implode and stream::implode respectively.
func::implode() {
  # 1. Function form.
  if [ "$#" -eq 3 ]; then
    local __implode_pieces=()
    func::array_values __implode_pieces "${3}"
    local __implode_size="${#__implode_pieces[*]}"
    local __implode_i=0
    local __implode_result=''
    while (( __implode_i < __implode_size )); do
      if (( __implode_i != 0 )); then
        __implode_result+="${2}"
      fi
      __implode_result+="${__implode_pieces[${__implode_i}]}"
      (( __implode_i += 1 )) || true
    done
    func::let "${1}" "${__implode_result}"
  elif [ "$#" -eq 2 ]; then
    DEPRECATED
    sub::implode "$@"
  elif [ "$#" -eq 1 ]; then
    DEPRECATED
    stream::implode "$@"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::implode() {
  if [ "$#" -eq 2 ]; then
    local __implode_output=''
    func::implode __implode_output "${1}" "${2}"
    sub::println "${__implode_output}"
  elif [ "$#" -eq 1 ]; then
    sub::implode "${IFS:0:1}" "${1}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::implode() {
  if [ "$#" -eq 1 ]; then
    local LINE=()
    while func::readarray; do
      sub::implode "${1}" LINE
    done
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

func::join() { func::implode "$@"; }
sub::join() { sub::implode "$@"; }
stream::join() { stream::implode "$@"; }

# ltrim -- Strips whitespace(s) from the beginning of a string.
#
# Strips whitespace (or other characters) from the beginning of a string.
#
# Usage:
#     // 1-a. Function form.
#     void func::ltrim(string* variable)
#     // 1-b. Function form.
#     void func::ltrim(string* variable, string input)
func::ltrim() {
  if [ "$#" -eq 1 ]; then
    eval "${1}=\"\${${1}#\"\${${1}%%[![:space:]]*}\"}\""
  elif [ "$#" -eq 2 ]; then
    func::let "${1}" "${2}"
    func::ltrim "${1}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# md5 -- Calculates a MD5 hash.
#
# Usage:
#     // 1. Function form.
#     void func::md5(string* variable, string data)
#     // 2. Command form.
#     void sub::md5(string data, bool binary = false) > hash
#     // 3. Stream form.
#     void stream::md5(bool binary = false) < input > hash
func::md5() {
  if [ "$#" -eq 2 ]; then
    local __md5_file=''
    func::tmpfile __md5_file
    sub::md5 "${2}" 0 > "${__md5_file}"
    func::file_get_contents "${1}" "${__md5_file}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::md5() {
  if [ "$#" -eq 2 ]; then
    sub::print "${1}" | stream::md5 "${2}"
  elif [ "$#" -eq 1 ]; then
    sub::md5 "$@" 0
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::md5() {
  if [ "$#" -eq 1 ]; then
    if [ "${1}" -eq 0 ]; then
      stream::md5 1 | stream::bin2hex
    else
      openssl md5 -binary
    fi
  elif [ "$#" -eq 0 ]; then
    stream::md5 0
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# ord -- Gets a character's ASCII code.
#
# Sets ASCII value of character to variable.
#
# Usage:
#     // 1-a. Function form.
#     void func::ord(string* variable, string character)
#     // 1-b. Function form.
#     void func::ord(string* variable)
#     // 2. Command form.
#     void sub::ord(string character) > output
func::ord() {
  if [ "$#" -eq 2 ]; then
    func::let "${1}" "$(printf '%d' \'"${2}")"
  elif [ "$#" -eq 1 ]; then
    local __ord_value=''
    func::strcpy __ord_value "${2}"
    func::ord "${1}" "${__ord_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::ord() {
  if [ "$#" -eq 1 ]; then
    local __ord_variable=''
    func::ord __ord_variable "${1}"
    func::println "${__ord_variable}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# print -- Prints a message.
#
# Print message to the standard output.  While "echo" consumes flags,
# print does not consume any flags, so this is theoretically safe.
#
# Usage:
#     // DEPRECATED
#     void func::print(string message...) > output
#     // 1. Command form.
#     void sub::print(string message...) > output
func::print() {
  DEPRECATED
  printf "%s" "$*"
}

sub::print() {
  IFS=' ' eval 'printf "%s" "$*"'
}

# println -- Prints a message with a new line.
#
# Print message to the standard output with a new line.  While "echo" consumes
# flags, println does not consume any flags, so this is theoretically safe.
#
# Usage:
#     // DEPRECATED.
#     void func::println(string message...) > output
#     // 1. Command form.
#     void sub::println(string message...) > output
func::println() {
  DEPRECATED
  printf "%s\n" "$*"
}

sub::println() {
  IFS=' ' eval 'printf "%s\n" "$*"'
}

# rtrim -- Strips whitespace(s) from the end of a string.
#
# Strips whitespace (or other characters) from the end of a string.
#
# Usage:
#     // 1-a. Function form.
#     void func::rtrim(string* output, string input)
#     // 1-b. Function form.
#     void func::rtrim(string* variable)
#     // 2. Command form.
#     void sub::rtrim(string value) > output
#     // 3. Stream form.
#     void stream::rtrim() < input > output
func::rtrim() {
  if [ "$#" -eq 1 ]; then
    eval "${1}=\"\${${1}%\"\${${1}##*[![:space:]]}\"}\""
  elif [ "$#" -eq 2 ]; then
    func::let "${1}" "${2}"
    func::rtrim "${1}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::rtrim() {
  if [ "$#" -eq 1 ]; then
    local __rtrim_value="$1"
    func::rtrim __rtrim_value
    sub::println "${__rtrim_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::rtrim() {
  if [ "$#" -eq 0 ]; then
    local LINE='' NEWLINE=''
    while func::readline; do
      func::rtrim LINE
      sub::print "${LINE}${NEWLINE}"
    done
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# str_replace -- Replaces a substring with another substring.
#
# Replace search with replace in *subject.
#
# Usage:
#     // 1. Function form.
#     void func::str_replace(string* subject, string search, string replace)
#     // 2. Command form.
#     void sub::str_replace(
#         string input, string search, string replace) > output
#     // 3. Stream form.
#     void stream::str_replace(string search, string replace) < input > output
func::str_replace() {
  if [ "$#" -eq 3 ]; then
    eval "${1}=\"\${${1}//\"\${2}\"/\${3}}\""
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::str_replace() {
  if [ "$#" -eq 3 ]; then
    local __str_replace_value="${1}"
    func::str_replace __str_replace_value "${2}" "${3}"
    sub::println "${__str_replace_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::str_replace() {
  if [ "$#" -eq 2 ]; then
    local __str_replace_search="${1}"
    local __str_replace_replace="${2}"
    func::str_replace __str_replace_search '\' '\\'
    func::str_replace __str_replace_search '/' '\/'
    func::str_replace __str_replace_search '.' '\.'
    func::str_replace __str_replace_search '*' '\*'
    func::str_replace __str_replace_search '^' '\^'
    func::str_replace __str_replace_search '$' '\$'
    func::str_replace __str_replace_search '[' '\['
    func::str_replace __str_replace_search ']' '\]'
    func::str_replace __str_replace_replace '\' '\\'
    func::str_replace __str_replace_replace '/' '\/'
    func::str_replace __str_replace_replace '&' '\&'
    sed -e "s/${__str_replace_search}/${__str_replace_replace}/g"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# strcpy -- Copies a string from a variable to another variable.
#
# Assigns the content of a variable specified as source into destination.
#
# Usage:
#     // 1. Function form.
#     void func::strcpy(string* destination, string *source)
func::strcpy() {
  if [ "$#" -eq 2 ]; then
    eval "${1}=\"\${${2}}\""
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# strtolower -- Makes a string lowercase.
#
# strtolower makes a string lowercase.
#
# Usage:
#     // 1. Function form.
#     void func::strtolower(string* variable)
#     // 2. Subroutine form.
#     void sub::strtolower(string input) > output
#     // 3. Stream form.
#     void stream::strtolower() < input > output
func::strtolower() {
  if [ "$#" -eq 1 ]; then
    local __strtolower_variable="${1}"
    local __strtolower_value=''
    func::strcpy __strtolower_value "${__strtolower_variable}"
    # This is faster than tr for short strings.
    # TODO(imos): Use ${variable,,} instead once Mac OSX supports BASH 4.
    __strtolower_value="${__strtolower_value//A/a}"
    __strtolower_value="${__strtolower_value//B/b}"
    __strtolower_value="${__strtolower_value//C/c}"
    __strtolower_value="${__strtolower_value//D/d}"
    __strtolower_value="${__strtolower_value//E/e}"
    __strtolower_value="${__strtolower_value//F/f}"
    __strtolower_value="${__strtolower_value//G/g}"
    __strtolower_value="${__strtolower_value//H/h}"
    __strtolower_value="${__strtolower_value//I/i}"
    __strtolower_value="${__strtolower_value//J/j}"
    __strtolower_value="${__strtolower_value//K/k}"
    __strtolower_value="${__strtolower_value//L/l}"
    __strtolower_value="${__strtolower_value//M/m}"
    __strtolower_value="${__strtolower_value//N/n}"
    __strtolower_value="${__strtolower_value//O/o}"
    __strtolower_value="${__strtolower_value//P/p}"
    __strtolower_value="${__strtolower_value//Q/q}"
    __strtolower_value="${__strtolower_value//R/r}"
    __strtolower_value="${__strtolower_value//S/s}"
    __strtolower_value="${__strtolower_value//T/t}"
    __strtolower_value="${__strtolower_value//U/u}"
    __strtolower_value="${__strtolower_value//V/v}"
    __strtolower_value="${__strtolower_value//W/w}"
    __strtolower_value="${__strtolower_value//X/x}"
    __strtolower_value="${__strtolower_value//Y/y}"
    __strtolower_value="${__strtolower_value//Z/z}"
    func::let "${__strtolower_variable}" "${__strtolower_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::strtolower() {
  if [ "$#" -eq 1 ]; then
    local value="${1}"
    func::strtolower value
    sub::println "${value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::strtolower() {
  if [ "$#" -eq 0 ]; then
    tr '[A-Z]' '[a-z]'
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# strtoupper -- Makes a string uppercase.
#
# strtoupper makes a string uppercase.
#
# Usage:
#     // 1. Function form.
#     void func::strtoupper(string* variable)
#     // 2. Subroutine form.
#     void sub::strtoupper(string input) > output
#     // 3. Stream form.
#     void stream::strtoupper() < input > output
func::strtoupper() {
  if [ "$#" -eq 1 ]; then
    local __strtoupper_variable="${1}"
    local __strtoupper_value=''
    func::strcpy __strtoupper_value "${__strtoupper_variable}"
    # This is faster than tr for short strings.
    # TODO(imos): Use ${variable^^} instead once Mac OSX supports BASH 4.
    __strtoupper_value="${__strtoupper_value//a/A}"
    __strtoupper_value="${__strtoupper_value//b/B}"
    __strtoupper_value="${__strtoupper_value//c/C}"
    __strtoupper_value="${__strtoupper_value//d/D}"
    __strtoupper_value="${__strtoupper_value//e/E}"
    __strtoupper_value="${__strtoupper_value//f/F}"
    __strtoupper_value="${__strtoupper_value//g/G}"
    __strtoupper_value="${__strtoupper_value//h/H}"
    __strtoupper_value="${__strtoupper_value//i/I}"
    __strtoupper_value="${__strtoupper_value//j/J}"
    __strtoupper_value="${__strtoupper_value//k/K}"
    __strtoupper_value="${__strtoupper_value//l/L}"
    __strtoupper_value="${__strtoupper_value//m/M}"
    __strtoupper_value="${__strtoupper_value//n/N}"
    __strtoupper_value="${__strtoupper_value//o/O}"
    __strtoupper_value="${__strtoupper_value//p/P}"
    __strtoupper_value="${__strtoupper_value//q/Q}"
    __strtoupper_value="${__strtoupper_value//r/R}"
    __strtoupper_value="${__strtoupper_value//s/S}"
    __strtoupper_value="${__strtoupper_value//t/T}"
    __strtoupper_value="${__strtoupper_value//u/U}"
    __strtoupper_value="${__strtoupper_value//v/V}"
    __strtoupper_value="${__strtoupper_value//w/W}"
    __strtoupper_value="${__strtoupper_value//x/X}"
    __strtoupper_value="${__strtoupper_value//y/Y}"
    __strtoupper_value="${__strtoupper_value//z/Z}"
    func::let "${__strtoupper_variable}" "${__strtoupper_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::strtoupper() {
  if [ "$#" -eq 1 ]; then
    local value="${1}"
    func::strtoupper value
    sub::println "${value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

stream::strtoupper() {
  if [ "$#" -eq 0 ]; then
    tr '[a-z]' '[A-Z]'
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# substr -- Returns a substring.
#
# substr returns a substring of a string specfied by start and length.
#
# Usage:
#     // 1. Function form.
#     void func::substr(
#         string* output, string input, string start, string length)
#     void func::substr(
#         string* output, string input, string start)
#     // 2. Command form.
#     void sub::substr(string input, string start, string length) > output
#     void sub::substr(string input, string start) > output
func::substr() {
  if [ "$#" -eq 4 ]; then
    local __substr_size="${#2}"
    local __substr_start="${3}"
    local __substr_length="${4}"
    (( __substr_start = ( __substr_start < 0 )
                      ? __substr_size + __substr_start : __substr_start,
       __substr_start = ( __substr_start < 0 ) ? 0 : __substr_start,
       __substr_length = ( __substr_length < 0 )
                       ? __substr_size + __substr_length - __substr_start
                       : __substr_length,
       __substr_length = ( __substr_length < 0 ) ? 0 : __substr_length
    )) || true
    func::let "${1}" "${2:${__substr_start}:${__substr_length}}"
  elif [ "$#" -eq 3 ]; then
    func::substr "${1}" "${2}" "${3}" "${#2}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::substr() {
  if [ "$#" -eq 3 -o "$#" -eq 2 ]; then
    local __substr_value=''
    func::substr __substr_value "$@"
    sub::println "${__substr_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# trim -- Strips whitespaces from both sides.
#
# trim strips whitespaces (or other characters) from the beginning and end of a
# string.
#
# Usage:
#     // 1-a. Function format.
#     void func::trim(string* output, string input)
#     // 1-b. Function format.
#     void func::trim(string* variable)
func::trim() {
  if [ "$#" -eq 1 ]; then
    func::rtrim "${1}"
    func::ltrim "${1}"
  elif [ "$#" -eq 2 ]; then
    func::let "${1}" "${2}"
    func::trim "${1}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# ASSERT_ALIVE -- Asserts a command successfully dies.
#
# ASSERT_ALIVE asserts that a command dies with a zero return value.
#
# Usage:
#     void ASSERT_ALIVE(string arguments,...)
ASSERT_ALIVE() {
  __ASSERT EXPECT_ALIVE "$@"
}

# ASSERT_DEATH -- Asserts a command unsuccessfully dies.
#
# ASSERT_DEATH asserts that a command dies with a non-zero return value.
#
# Usage:
#     void ASSERT_DEATH(string arguments,...)
ASSERT_DEATH() {
  __ASSERT EXPECT_DEATH "$@"
}

# ASSERT_EQ -- Asserts two arguments are equal.
#
# ASSERT_EQ asserts two arguments are equal.
#
# Usage:
#     void ASSERT_EQ(string expected, string actual)
#
# Alias:
#   ASSERT_STREQ is an alias of ASSERT_EQ.
ASSERT_EQ() {
  __ASSERT EXPECT_EQ "$@"
}

ASSERT_STREQ() {
  ASSERT_EQ "$@"
}

# ASSERT_FALSE -- Expects a command fails.
#
# ASSERT_FALSE expects the command fails (returns a non-zero value).
#
# Usage:
#     void ASSERT_FALSE(string arguments,...)
ASSERT_FALSE() {
  __ASSERT EXPECT_FALSE "$@"
}

# ASSERT_NE -- Asserts two arguments are not equal.
#
# ASSERT_NE asserts two arguments are not equal.
#
# Usage:
#     void ASSERT_NE(string target, string actual)
#
# Alias:
#   ASSERT_STRNE is an alias of ASSERT_NE.
ASSERT_NE() {
  __ASSERT EXPECT_NE "$@"
}

ASSERT_STRNE() {
  ASSERT_NE "$@"
}

# ASSERT_TRUE -- Asserts a command succeeds.
#
# ASSERT_TRUE asserts the command succeeds (returns 0).
#
# Usage:
#     void ASSERT_TRUE(string arguments,...)
ASSERT_TRUE() {
  __ASSERT EXPECT_TRUE "$@"
}

# EXPECT_ALIVE -- Expects a command successfully exits.
#
# EXPECT_ALIVE expects that a command exits with a zero return value.
#
# Usage:
#     void EXPECT_ALIVE(string arguments,...)
EXPECT_ALIVE() {
  "$@" &
  if ! wait "$!"; then
    LOG ERROR 'Command died unexpectedly:' "$@"
    FAILURE
    return
  fi
  LOG INFO 'Command did not die as expected:' "$@"
}

# EXPECT_DEATH -- Expects a command unsuccessfully dies.
#
# EXPECT_DEATH expects that a command dies with a non-zero return value.
#
# Usage:
#     void EXPECT_DEATH(string arguments,...)
EXPECT_DEATH() {
  "$@" &
  if wait "$!"; then
    LOG ERROR 'Command did not die unexpectedly:' "$@"
    FAILURE
    return
  fi
  LOG INFO 'Command died as expected:' "$@"
}

# EXPECT_EQ -- Expects two arguments are equal.
#
# EXPECT_EQ expects two arguments are equal.
#
# Usage:
#     void EXPECT_EQ(string expected, string actual)
#
# Alias:
#   EXPECT_STREQ is an alias of EXPECT_EQ.
EXPECT_EQ() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" != "$2" ]; then
      echo "  Actual: $2" >&2
      echo "Expected: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_EQ passes: '$1' == '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

EXPECT_STREQ() {
  EXPECT_EQ "$@"
}

# EXPECT_FALSE -- Expects a command fails.
#
# EXPECT_FALSE expects the command fails (returns a non-zero value).
#
# Usage:
#     void EXPECT_FALSE(string arguments,...)
EXPECT_FALSE() {
  if "$@"; then
    sub::println '  Actual: true' >&2
    sub::println 'Expected: false' >&2
    LOG ERROR 'EXPECT_FALSE failed:' "$@"
    FAILURE
    return
  fi
  LOG INFO 'EXPECT_FALSE passes:' "$@"
}

# EXPECT_GE -- Expects first one is greater than or equal to second one.
#
# EXPECT_GE expects first one is greater than or equal to second one.
#
# Usage:
#     void EXPECT_GE(string target, string actual)
#     void EXPECT_STRGE(string target, string actual)
EXPECT_GE() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" -lt "$2" ]; then
      echo "Actual: $2" >&2
      echo "Target: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_GE passes: '$1' >= '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

EXPECT_STRGE() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" \< "$2" ]; then
      echo "Actual: $2" >&2
      echo "Target: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_STRGE passes: '$1' >= '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

ASSERT_GE() {
  __ASSERT EXPECT_GE "$@"
}

ASSERT_STRGE() {
  __ASSERT EXPECT_STRGE "$@"
}

# EXPECT_GT -- Expects first one is greater than second one.
#
# EXPECT_GT expects first one is greater than second one.
#
# Usage:
#     void EXPECT_GT(string target, string actual)
#     void EXPECT_STRGT(string target, string actual)
EXPECT_GT() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" -le "$2" ]; then
      echo "Actual: $2" >&2
      echo "Target: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_GT passes: '$1' > '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

EXPECT_STRGT() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" \<= "$2" ]; then
      echo "Actual: $2" >&2
      echo "Target: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_STRGT passes: '$1' > '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

ASSERT_GT() {
  __ASSERT EXPECT_GT "$@"
}

ASSERT_STRGT() {
  __ASSERT EXPECT_STRGT "$@"
}

# EXPECT_LE -- Expects first one is less than or equal to second one.
#
# EXPECT_LE expects first one is less than or equal to second one.
#
# Usage:
#     void EXPECT_LE(string target, string actual)
#     void EXPECT_STRLE(string target, string actual)
EXPECT_LE() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" -gt "$2" ]; then
      echo "Actual: $2" >&2
      echo "Target: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_LE passes: '$1' <= '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

EXPECT_STRLE() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" \> "$2" ]; then
      echo "Actual: $2" >&2
      echo "Target: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_STRLE passes: '$1' <= '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

ASSERT_LE() {
  __ASSERT EXPECT_LE "$@"
}

ASSERT_STRLE() {
  __ASSERT EXPECT_STRLE "$@"
}

# EXPECT_LT -- Expects first one is less than second one.
#
# EXPECT_LT expects first one is less than second one.
#
# Usage:
#     void EXPECT_LT(string target, string actual)
#     void EXPECT_STRLT(string target, string actual)
EXPECT_LT() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" -ge "$2" ]; then
      echo "Actual: $2" >&2
      echo "Target: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_LT passes: '$1' < '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

EXPECT_STRLT() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" \>= "$2" ]; then
      echo "Actual: $2" >&2
      echo "Target: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_STRLT passes: '$1' < '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

ASSERT_LT() {
  __ASSERT EXPECT_LT "$@"
}

ASSERT_STRLT() {
  __ASSERT EXPECT_STRLT "$@"
}

# EXPECT_NE -- Expects two arguments are not equal.
#
# EXPECT_NE expects two arguments are not equal.
#
# Usage:
#     void EXPECT_NE(string target, string actual)
#
# Alias:
#   EXPECT_STRNE is an alias of EXPECT_NE.
EXPECT_NE() {
  if [ "$#" -eq 2 ]; then
    if [ "$1" = "$2" ]; then
      echo "Actual: $2" >&2
      echo "Target: $1" >&2
      FAILURE
    fi
    LOG INFO "EXPECT_NE passes: '$1' != '$2'"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

EXPECT_STRNE() {
  EXPECT_NE "$@"
}

# EXPECT_TRUE -- Expects a command succeeds.
#
# EXPECT_TRUE expects the command succeeds (returns 0).
#
# Usage:
#     void EXPECT_TRUE(string arguments,...)
EXPECT_TRUE() {
  if ! "$@"; then
    sub::println '  Actual: false' >&2
    sub::println 'Expected: true' >&2
    LOG ERROR 'EXPECT_TRUE failed:' "$@"
    FAILURE
    return
  fi
  LOG INFO 'EXPECT_TRUE passes:' "$@"
}

# FAILURE -- Declares a test case failed.
#
# FAILURE sets the test case as failed and shows a stack trace.
#
# Usage:
#     void FAILURE()
FAILURE() {
  IMOSH_TEST_IS_FAILED=1
  imosh::stack_trace --skip_imosh '*** Check failure ***'
}

__ASSERT() {
  local last_state="${IMOSH_TEST_IS_FAILED}"
  IMOSH_TEST_IS_FAILED=0
  "$@"
  if (( IMOSH_TEST_IS_FAILED )); then
    exit 1
  fi
  IMOSH_TEST_IS_FAILED="${last_state}"
}

# test_file -- Tests a file.
#
# test_file tests test cases in a file.
#
# Usage:
#     void imosh::test_file(string file_path)
imosh::test_case() {
  if [ "$#" -eq 1 ]; then
    IMOSH_TEST_IS_FAILED=0
    "test::${1}"
    (( ! IMOSH_TEST_IS_FAILED )) || exit 1
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

imosh::test_file() {
  if [ "$#" -eq 1 ]; then
    sub::print   "${IMOSH_COLOR_GREEN}[==========]" >&2
    sub::println "${IMOSH_STYLE_DEFAULT} Running tests for ${1}." >&2
    IMOSH_TESTING=0 source "${1}" || exit 1
    ( ( declare -F | grep 'test::' ) || true ) >"${IMOSH_TMPDIR}/test_func"
    if [ "$(cat "${IMOSH_TMPDIR}/test_func")" == '' ]; then
      LOG FATAL "${1} has no test."
    fi
    exec 3>&2
    while read line; do
      function="${line##*test::}"
      sub::print   "${IMOSH_COLOR_GREEN}[ RUN      ]" >&2
      sub::println "${IMOSH_STYLE_DEFAULT} ${function}" >&2
      {
        time -p {
          imosh::test_case "${function}" 2>&1 &
          wait $!
        }
      } 2>"${IMOSH_TMPDIR}/time" \
        1>"${IMOSH_TMPDIR}/stdout" &
      if wait $!; then
        func::file_get_contents time "${IMOSH_TMPDIR}/time"
        func::greg_replace time '+([[:space:]])' ' '
        func::trim time
        sub::print   "${IMOSH_COLOR_GREEN}[       OK ]" >&2
        sub::println "${IMOSH_STYLE_DEFAULT} ${function} (${time})" >&2
      else
        cat "${IMOSH_TMPDIR}/stdout"
        func::file_get_contents time "${IMOSH_TMPDIR}/time"
        func::greg_replace time '+([[:space:]])' ' '
        func::trim time
        sub::print   "${IMOSH_COLOR_RED}[  FAILED  ]" >&2
        sub::println "${IMOSH_STYLE_DEFAULT} ${function} (${time})" >&2
        IMOSH_TEST_IS_FAILED=1
      fi
    done <"${IMOSH_TMPDIR}/test_func"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

imosh::test_files() {
  local IMOSH_TEST_IS_FAILED=0
  if [ "$#" -eq 1 ]; then
    imosh::test_file "${1}"
  else
    local ppid=()
    local files=()
    local file=''
    local index=0
    for file in "$@"; do
      sub::throttle 4
      "${BASH}" "${BASH_SOURCE}" "${file}" \
          >"${IMOSH_TMPDIR}/test_index_${index}.stdout" \
          2>"${IMOSH_TMPDIR}/test_index_${index}.stderr" &
      ppid+=("$!")
      files+=("${file}")
      (( index += 1 ))
    done
    index=0
    while [ "${index}" -lt "${#ppid[*]}" ]; do
      if ! wait "${ppid[${index}]}"; then
        IMOSH_TEST_IS_FAILED=1
        LOG ERROR "${files[${index}]} failed."
      fi
      cat "${IMOSH_TMPDIR}/test_index_${index}.stdout"
      cat "${IMOSH_TMPDIR}/test_index_${index}.stderr" >&2
      sub::println
      (( index += 1 ))
    done
  fi
  if (( IMOSH_TEST_IS_FAILED )); then
    exit 1
  fi
}

# boolval -- Casts a variable as a boolean value.
#
# Casts variable as a boolean value.  If it fails, returns 1.
#
# Usage:
#     bool func::boolval(string* variable)
func::boolval() {
  if [ "$#" -eq 2 ]; then
    func::let "${1}" 0
    local __boolval_value="${2}"
    func::trim __boolval_value
    if [ "${__boolval_value}" = '' ] || \
       [[ "${__boolval_value}" =~ ^F|f|[Ff]alse$ ]]; then
      return
    elif [[ "${__boolval_value}" =~ ^T|t|[Tt]rue$ ]]; then
      func::let "${1}" 1
    else
      func::intval __boolval_value || return "$?"
      if (( __boolval_value != 0 )); then
        func::let "${1}" 1
      fi
    fi
  elif [ "$#" -eq 1 ]; then
    eval "func::boolval \"\${1}\" \"\${${1}}\" || return \"\$?\""
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::boolval() {
  if [ "$#" -eq 1 ]; then
    local __boolval_sub_value="${1}"
    func::booval __boolval_sub_value || return "$?"
    sub::println "${__boolval_sub_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# cast -- Casts a variable.
#
# Casts variable into a specified type.
#
# Usage:
#     // 1. Function form.
#     bool func::cast(variant* variable, string type)
#     // 2. Function form. (Dies if conversion fails.)
#     void func::cast_or_die(variant* variable, string type)
func::cast() {
  if [ "$#" -eq 2 ]; then
    if [ "${2}" = 'LIST' ]; then
      func::cast "${1}" 'MULTISTRING' || return "$?"
      return
    fi
    case "${2}" in
      'MULTI'*)
        local __cast_values=()
        local __cast_element_type="${2:5}"
        func::array_values __cast_values "${1}"
        if [ "${#__cast_values[*]}" -ne 0 ]; then
          local __cast_index=0
          for __cast_index in "${!__cast_values[@]}"; do
            local __cast_value="${__cast_values[${__cast_index}]}"
            func::cast __cast_value "${__cast_element_type}" || return "$?"
            __cast_values["${__cast_index}"]="${__cast_value}"
          done
        fi
        func::array_values "${1}" __cast_values
        ;;
      'INT')     func::intval "${1}" || return "$?";;
      'FLOAT')   func::floatval "${1}" || return "$?";;
      'STRING')  func::strval "${1}" || return "$?";;
      'BOOL')    func::boolval "${1}" || return "$?";;
      'VARIANT') return 0;;
      *)       LOG FATAL "Unknown type: ${2}";;
    esac
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

func::cast_or_die() {
  if ! func::cast "${@}"; then
    IFS=' ' eval 'LOG FATAL "Type mismatch: ${*}"'
  fi
}

# floatval -- Casts a variable as a float value.
#
# Casts variable into float type.  If it fails, returns 1.
#
# Usage:
#     // 1-a. Function form.
#     bool func::floatval(string* output, string input)
#     // 1-b. Inplace function form.
#     bool func::floatval(string* variable)
#     // 2. Command form.
#     bool sub::floatval(string input) > output
func::floatval() {
  if [ "$#" -eq 2 ]; then
    if [[ ! "${2}" =~ ^[[:space:]]*(-?[0-9]+(\.[0-9]+)?) ]]; then
      return 1
    fi
    func::let "${1}" "${BASH_REMATCH[1]}"
  elif [ "$#" -eq 1 ]; then
    eval "func::floatval \"\${1}\" \"\${${1}}\" || return \"\$?\""
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::floatval() {
  if [ "$#" -eq 1 ]; then
    local __floatval_value="${1}"
    func::floatval __floatval_value || return "$?"
    sub::println "${__floatval_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# intval -- Casts a variable as an integer value.
#
# Casts variable into integer type.  If it fails, returns 1.
#
# Usage:
#     // 1-a. Function from.
#     bool func::intval(string* output, string input)
#     // 1-b. Inplace function form.
#     bool func::intval(string* variable)
#     // 2. Command form.
#     bool sub::intval(string input) > output
func::intval() {
  if [ "$#" -eq 2 ]; then
    if [[ ! "${2}" =~ ^[[:space:]]*(-?[0-9]+) ]]; then
      func::let "${1}" 0
      return 1
    fi
    func::let "${1}" "${BASH_REMATCH[1]}"
  elif [ "$#" -eq 1 ]; then
    eval "func::intval \"\${1}\" \"\${${1}}\" || return \"\$?\""
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::intval() {
  if [ "$#" -eq 1 ]; then
    local __intval_value="${1}"
    func::intval __intval_value || return "$?"
    sub::println "${__intval_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# isset -- Checks if a variable exists.
#
# Returns true iff variable exists.
#
# Usage:
#     // 1. Function form.
#     void func::isset(bool* result, variant* variable)
#     // 2. Command form.
#     bool func::isset(variant* variable)
#
# CAVEATS:
#   func::isset returns true for uninitialized variables in BASH 3, and returns
#   false for them in BASH 4.
func::isset() {
  if [ "$#" -eq 2 ]; then
    eval "local __isset_state=\"\${${2}+set}\""
    if [ "${__isset_state}" = 'set' ]; then
      func::let "${1}" 1
    else
      func::let "${1}" 0
    fi
  elif [ "$#" -eq 1 ]; then
    DEPRECATED
    sub::isset "$@" || return "$?"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::isset() {
  if [ "$#" -eq 1 ]; then
    local __isset_return=0
    func::isset __isset_return "${1}"
    (( __isset_return )) || return 1
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# let -- Assigns a value into a variable.
#
# Assigns value into *destination.
#
# Usage:
#     // 1. Function form.
#     func::let(string* destination, string value)
func::let() {
  if [ "$#" -eq 2 ]; then
    eval "${1}=\"\${2}\""
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# strval -- Casts a variable as a string value.
#
# Casts variable into string type.
#
# Usage:
#     // 1-a. Function from.
#     void func::strval(string* output, string input)
#     // 1-b. Inplace function form.
#     void func::strval(string* variable)
#     // 2. Command form.
#     bool sub::strval(string input) > output
func::strval() {
  if [ "$#" -eq 2 ]; then
    func::let "${1}" "${2}"
  elif [ "$#" -eq 1 ]; then
    func::strcpy "${1}" "${1}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

sub::strval() {
  if [ "$#" -eq 1 ]; then
    local __strval_value="${1}"
    func::strval __strval_value || return "$?"
    sub::println "${__strval_value}"
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# Parses arguments without getopt.
imosh::internal::parse_args() {
  local class_name="$1"; shift

  local upper_class_name="${class_name}"
  func::strtoupper upper_class_name
  local arg arg_name arg_value
  IMOSH_ARGV=()
  IMOSH_ARGS=()
  while [ "$#" != '0' ]; do
    if sub::isset IMOSH_PREDICATE &&
       [ "${upper_class_name}" = 'FLAG' ] &&
       [ "${#IMOSH_ARGV[*]}" -eq "${IMOSH_PREDICATE}" ]; then
      IMOSH_ARGV+=("$@")
      break
    fi
    local arg="$1"
    shift
    if [ "${arg:0:1}" != '-' ]; then
      IMOSH_ARGV+=("${arg}")
      continue
    fi
    if [[ "${arg}" =~ ^-[0-9] ]]; then
      IMOSH_ARGV+=("${arg}")
      continue
    fi
    if [ "${arg}" = '--' ]; then
      IMOSH_ARGV+=("$@")
      break
    fi
    case "${arg}" in
      --*) arg="${arg:2}";;
      -*) arg="${arg:1}";;
    esac
    arg_name="${arg%%=*}"
    if [[ ! "${arg_name}" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
      LOG FATAL "${class_name} name is bad: ${arg_name}"
    fi
    arg_value="${arg:${#arg_name}}"
    # If the argument does not have "=", it should be a boolean flag or it
    # should consume its next argument.
    if [ "${arg_value:0:1}" = '=' ]; then
      arg_value="${arg_value:1}"
    # Preprocess for boolean flags (e.g. --name, --noname) and separated flags
    # (e.g. --name value).
    else
      # If it is a negative boolean flag (--noname).
      if [ "${arg_name:0:2}" = 'no' ] &&
         sub::isset "${upper_class_name}S_${arg_name:2}" &&
         ( [ "${class_name}" != 'flag' ] ||
           [ "$(imosh::internal::flag_type "${arg_name:2}")" = 'BOOL' ] ); then
        arg_name="${arg_name:2}"
        arg_value=0
      else
        if ! sub::isset "${upper_class_name}S_${arg_name}"; then
          LOG FATAL "no such bool ${class_name} is defined:" \
                    "(${upper_class_name}S_)${arg_name}"
        fi
        if [ "${class_name}" != 'flag' ] ||
           [ "$(imosh::internal::flag_type "${arg_name}")" = 'BOOL' ]; then
          arg_value=1
        else
          if [ "$#" -eq 0 ]; then
            LOG FATAL "the ${arg_name} flag requires a value"
          fi
          arg_value="${1}"
          shift
        fi
      fi
    fi
    if [ "${class_name}" = 'flag' ]; then
      local type="$(imosh::internal::flag_type "${arg_name}")"
      local single_type="${type}"
      if [ "${type:0:5}" = 'MULTI' ]; then
        single_type="${type:5}"
      fi
      if [ "${type}" = 'LIST' ]; then
        # TODO(imos): Support delimiter.
        func::explode arg_value ',' "${arg_value}"
      fi
      CHECK --message="FLAGS_${arg_name} is invalid: ${arg_value}" \
            func::cast arg_value "${single_type}"
      local is_default=0
      func::strcpy 'is_default' "__IMOSH_FLAGS_IS_DEFAULT_${arg_name}"
      func::let "__IMOSH_FLAGS_IS_DEFAULT_${arg_name}" '0'
      if [ "${type}" = 'LIST' ]; then
        # Set values here.  FLAGS_* are global variables, and this does not
        # cause scope issues.
        func::array_values "FLAGS_${arg_name}" arg_value
        continue
      fi
      if [ "${type:0:5}" = 'MULTI' ]; then
        if (( is_default )); then
          eval "FLAGS_${arg_name}=(\"\${arg_value}\")"
        else
          eval "FLAGS_${arg_name}+=(\"\${arg_value}\")"
        fi
        continue
      fi
    fi
    if ! sub::isset "${upper_class_name}S_${arg_name}"; then
      LOG FATAL "No such ${class_name} is defined: ${arg_name}"
    fi
    func::str_replace arg_value "'" "'\\''"
    IMOSH_ARGS+=("${upper_class_name}S_${arg_name}='${arg_value}'")
  done
}

# __IMOSH_FLAGS_TYPE_<flag name>=<flag type>
# __IMOSH_FLAGS_DESCRIPTION_<flag name>=<description>
# __IMOSH_FLAGS_GROUP_<flag name>=<group>
# __IMOSH_FLAGS_ALIASES=(from:to ...)
# __IMOSH_FLAGS_IS_DEFAULT_<flag name>=<is default>

imosh::internal::flag_type() {
  local name="$1"

  if [ "$#" -ne 1 ]; then
    LOG FATAL 'flag_type requires 1 arugument.'
  fi
  eval "sub::print \"\${__IMOSH_FLAGS_TYPE_${name}}\""
}

imosh::internal::define_flag() {
  local type="$1"; shift

  local ARGS_alias='' ARGS_alias_flag=0 ARGS_group='main'
  eval "${IMOSH_PARSE_ARGUMENTS}"

  if [ "$#" -lt 3 ]; then
    LOG FATAL 'DEFINE_${type} requires 3+ arguments.'
  fi
  local name="$1"; shift
  local default_value="$1"; shift
  local original_default_value="${default_value}"
  local description="$*"
  local group="${ARGS_group}"
  func::strtoupper group

  # Change the default value based on its corresponding environment variable.
  if sub::isset "IMOSH_FLAGS_${name}"; then
    func::strcpy default_value "IMOSH_FLAGS_${name}"
  fi
  if [ "${type}" = 'LIST' -o "${type:0:5}" = 'MULTI' ]; then
    if [ "${default_value}" = '' ]; then
      default_value=()
    else
      func::explode default_value ',' "${default_value}"
    fi
  fi
  CHECK \
      --message="${name}'s default value is invalid: ${original_default_value}." \
      func::cast default_value "${type}"
  if sub::isset "__IMOSH_FLAGS_TYPE_${name}"; then
    LOG FATAL "already defined flag: ${name}"
  fi
  if [ "${type}" = 'LIST' -o "${type:0:5}" = 'MULTI' ]; then
    func::array_values "FLAGS_${name}" 'default_value'
  else
    func::strcpy "FLAGS_${name}" 'default_value'
  fi
  func::strcpy "__IMOSH_FLAGS_TYPE_${name}" 'type'
  func::let "__IMOSH_FLAGS_IS_DEFAULT_${name}" '1'
  if [ "${ARGS_alias}" != '' ]; then
    imosh::internal::define_flag "${type}" --alias_flag \
        "${ARGS_alias}" "${original_default_value}" "${description}"
    __IMOSH_FLAGS_ALIASES+=("${name}:${ARGS_alias}")
  fi
  if (( ! ARGS_alias_flag )); then
    local escaped_default_value=''
    case "${type}" in
      'INT') escaped_default_value="${default_value}";;
      'BOOL')
        if (( default_value )); then
          escaped_default_value='true'
        else
          escaped_default_value='false'
        fi
        ;;
      *)
        escaped_default_value="${original_default_value}"
        func::escapeshellarg escaped_default_value
        ;;
    esac
    func::let "__IMOSH_FLAGS_DEFAULT_${name}" \
              "--${name}=${escaped_default_value}"
    if [ "${ARGS_alias}" != '' ]; then
      description+=" (Alias: --${ARGS_alias})"
    fi
    func::let "__IMOSH_FLAGS_DESCRIPTION_${name}" "${description}"
    if [ "${group}" != 'IMOSH' -a "${group}" != 'MAIN' ]; then
      func::let "__IMOSH_FLAGS_GROUP_${name}" "${group}"
    fi
    __IMOSH_FLAGS+=("${group}:${name}")
  fi
}

DEFINE_string() { imosh::internal::define_flag STRING "$@"; }
DEFINE_int() { imosh::internal::define_flag INT "$@"; }
DEFINE_bool() { imosh::internal::define_flag BOOL "$@"; }
DEFINE_double() { imosh::internal::define_flag DOUBLE "$@"; }
DEFINE_multistring() { imosh::internal::define_flag MULTISTRING "$@"; }
DEFINE_multiint() { imosh::internal::define_flag MULTIINT "$@"; }
DEFINE_multibool() { imosh::internal::define_flag MULTIBOOL "$@"; }
DEFINE_multidouble() { imosh::internal::define_flag MULTIDOUBLE "$@"; }
DEFINE_list() { imosh::internal::define_flag LIST "$@"; }

imosh::internal::get_main_script() {
  local depth="${#BASH_SOURCE[*]}"
  local main_script="${BASH_SOURCE[$((depth-1))]}"
  echo "${main_script}"
}

imosh::internal::get_usage() {
  local file="${1}"
  while IFS='' read -r line; do
    case "${line}" in
      '#!'*) continue;;
      '# '*) echo "${line:2}";;
      '#'*)  echo "${line:1}";;
      *)     break;;
    esac
  done < "${file}" > "${__IMOSH_CORE_TMPDIR}/usage"
  if [ -s "${__IMOSH_CORE_TMPDIR}/usage" ]; then
    cat "${__IMOSH_CORE_TMPDIR}/usage"
  else
    echo 'No description.'
  fi
}

imosh::internal::flag_groups() {
  local groups=()
  local group=''
  local main_group_exists=0
  local imosh_group_exists=0
  for flag_name in "${__IMOSH_FLAGS[@]}"; do
    local parts=()
    func::explode parts ':' "${flag_name}"
    group="${parts[0]}"
    local lower_group="${group}"
    func::strtolower lower_group
    if [ "${lower_group}" == 'main' ]; then
      main_group_exists=1
    elif [ "${lower_group}" == 'imosh' ]; then
      imosh_group_exists=1
    else
      groups+=("${group}")
    fi
  done
  if (( main_group_exists )); then
    echo 'main'
  fi
  if [ "${#groups[*]}" -ne 0 ]; then
    func::array_unique groups
    for group in "${groups[@]}"; do
      echo "${group}"
    done
  fi
  if (( imosh_group_exists && FLAGS_helpfull )); then
    echo 'imosh'
  fi
}

imosh::internal::group_flags() {
  local group="$1"
  local lower_group="${group}"
  func::strtolower lower_group

  local flags=()
  for flag_name in "${__IMOSH_FLAGS[@]}"; do
    local parts=()
    func::explode parts ':' "${flag_name}"
    local lower_part="${parts[0]}"
    func::strtolower lower_part
    if [ "${lower_group}" != "${lower_part}" ]; then
      continue
    fi
    flags+=("${parts[1]}")
  done
  func::sort flags
  for flag in "${flags[@]}"; do
    echo "${flag}"
  done
}

imosh::internal::man() {
  echo ".TH ${0##*/} 1"; echo
  echo '.SH DESCRIPTION'
  sub::usage --format=groff --notitle \
      "$(imosh::internal::get_main_script)"

  echo '.SH OPTIONS'
  for flag_group in $(imosh::internal::flag_groups); do
    local upper_flag_group="${flag_group}"
    func::strtoupper upper_flag_group
    echo ".SS ${upper_flag_group} OPTIONS"
    for flag_name in $(imosh::internal::group_flags "${flag_group}"); do
      echo '.TP'
      echo -n '\fB'
      eval "echo -n \"\${__IMOSH_FLAGS_DEFAULT_${flag_name}}\""
      echo '\fP'
      eval "echo \"\${__IMOSH_FLAGS_DESCRIPTION_${flag_name}}\""
      echo
    done
  done
}

imosh::internal::help() {
  sub::usage --format=text --notitle \
      "$(imosh::internal::get_main_script)"
  echo "OPTIONS:"
  for flag_group in $(imosh::internal::flag_groups); do
    local upper_flag_group="${flag_group}"
    func::strtoupper upper_flag_group
    echo "  ${upper_flag_group} OPTIONS:"
    for flag_name in $(imosh::internal::group_flags "${flag_group}"); do
      eval "echo \"    \${__IMOSH_FLAGS_DEFAULT_${flag_name}}\""
      eval "echo \"\${__IMOSH_FLAGS_DESCRIPTION_${flag_name}}\"" | \
          fold -s -w 70 | while IFS= read -r line; do
        sub::println "        ${line}"
      done
    done
  done
}

__imosh::help_markdown() {
  sub::usage --format=markdown --notitle \
      "$(imosh::internal::get_main_script)"
  echo "# Options"
  for flag_group in $(imosh::internal::flag_groups); do
    local upper_flag_group="${flag_group}"
    func::strtoupper upper_flag_group
    echo "## ${flag_group} options"
    for flag_name in $(imosh::internal::group_flags "${flag_group}"); do
      eval "echo \"* \${__IMOSH_FLAGS_DEFAULT_${flag_name}}\""
      eval "echo \"    * \${__IMOSH_FLAGS_DESCRIPTION_${flag_name}}\""
    done
  done
}

__imosh::help() {
  case "${FLAGS_help_format}" in
    groff)
      imosh::internal::man;;
    markdown)
      __imosh::help_markdown;;
    *)
      imosh::internal::help;;
  esac
}

imosh::internal::init() {
  imosh::internal::parse_args flag "$@"
  if [ "${#IMOSH_ARGS[*]}" -ne 0 ]; then
    eval "${IMOSH_ARGS[@]}"
  fi
  imosh::logging::init
  if [ "${#__IMOSH_FLAGS_ALIASES[*]}" -ne 0 ]; then
    for alias in "${__IMOSH_FLAGS_ALIASES[@]}"; do
      eval "FLAGS_${alias%%:*}=\"\${FLAGS_${alias#*:}}\""
      unset "FLAGS_${alias#*:}"
    done
  fi
  # Re-assign flag values so as to support flag aliases.
  if [ "${#IMOSH_ARGS[*]}" -ne 0 ]; then
    eval "${IMOSH_ARGS[@]}"
  fi
  if (( FLAGS_help || FLAGS_helpfull )) ||
     [ "${FLAGS_help_format}" != '' ]; then
    imosh::help
    exit 0
  fi
}

# imosh::help -- Shows help message.
#
# This shows a help message as --help flag does.
#
# Usage:
#   void imosh::help()
imosh::help() {
  if [ "$#" -eq 0 ]; then
    if [ "${FLAGS_help_format}" = '' ]; then
      if [ -t 1 ]; then
        FLAGS_help_format='groff'
      else
        FLAGS_help_format='text'
      fi
    fi
    if [ -t 1 -a "${FLAGS_help_format}" = 'groff' ]; then
      local man_file="${__IMOSH_CORE_TMPDIR}/man"
      __imosh::help >"${man_file}"
      man "${man_file}"
    else
      __imosh::help >&2
    fi
  else
    eval "${IMOSH_WRONG_NUMBER_OF_ARGUMENTS}"
  fi
}

# Usage:
#   imosh::stack_trace [--skip_imosh] [message...]
#
# Shows a stack trace.  Arguments are used as a message.
imosh::stack_trace() {
  local ARGS_skip_imosh=0
  eval "${IMOSH_PARSE_ARGUMENTS}"

  local max_depth="${#BASH_LINENO[*]}"
  local i=0
  if [ "$*" = '' ]; then
    echo 'imosh::stack_trace is called' >&2
  else
    echo "$*" >&2
  fi
  while (( i < max_depth - 1 )); do
    if [ "${BASH_SOURCE[$((i+1))]}" != "${BASH_SOURCE[0]}" ]; then
      break
    fi
    (( i += 1 )) || true
  done
  while (( i < max_depth - 1 )); do
    local lineno="${BASH_LINENO[$((i))]}"
    local file="${BASH_SOURCE[$((i+1))]}"
    local function="${FUNCNAME[$((i+1))]}"
    echo "  at ${function} (${file}:${lineno})" >&2
    (( i += 1 )) || true
  done
}

# IMOSH_PREDICATE declares the number of predicates.
unset IMOSH_PREDICATE

# Return if imosh is reloaded.  Operations in 50+ run level may have
# destructive operations, so they are skipped in reloading.
if [ "${__IMOSH_IS_LOADED+loaded}" = 'loaded' ]; then
  return
fi

# Color definitions.  A shell script should restore terminal's original color
# using IMOSH_STYLE_DEFAULT when it changes color or style.

readonly IMOSH_STYLE_DEFAULT=$'\033[0m'
readonly IMOSH_COLOR_DEFAULT=$'\033[0;39m'
readonly IMOSH_COLOR_BLACK=$'\033[0;30m'
readonly IMOSH_COLOR_RED=$'\033[0;31m'
readonly IMOSH_COLOR_GREEN=$'\033[0;32m'
readonly IMOSH_COLOR_YELLOW=$'\033[0;33m'
readonly IMOSH_COLOR_BLUE=$'\033[0;34m'
readonly IMOSH_COLOR_MAGENTA=$'\033[0;35m'
readonly IMOSH_COLOR_CYAN=$'\033[0;36m'
readonly IMOSH_COLOR_WHITE=$'\033[0;37m'

readonly IMOSH_PARSE_ARGUMENTS='
    local IMOSH_ARGV IMOSH_ARGS
    imosh::internal::parse_args arg "$@"
    if [ "${#IMOSH_ARGS[*]}" -ne 0 ]; then
      local __imosh_parse_arguments_arg=""
      for __imosh_parse_arguments_arg in "${IMOSH_ARGS[@]}"; do
        eval "local ${__imosh_parse_arguments_arg}"
      done
    fi
    if [ "${#IMOSH_ARGV[*]}" -ne 0 ]; then
      set -- "${IMOSH_ARGV[@]}"
    else
      set --
    fi'

readonly IMOSH_WRONG_NUMBER_OF_ARGUMENTS='
    LOG ERROR "Wrong number of arguments: $#"
    return 1'

readonly IMOSH_INIT='
    set -e -u
    imosh::internal::init "$@"
    if [ "${#IMOSH_ARGV[*]}" -ne 0 ]; then
      set -- "${IMOSH_ARGV[@]}"
    else
      set --
    fi'

__IMOSH_FLAGS=()
__IMOSH_FLAGS_ALIASES=()

# Process ID that imosh initially runs on.
readonly IMOSH_ROOT_PID="$$"

# Variable not to output stack trace multiple times when exiting.
__IMOSH_STACK_TRACED=0

if ! sub::isset UNAME; then
  UNAME="$(uname)"
fi

__imosh::error_handler() {
  local exit_code="$?"
  __IMOSH_STACK_TRACED=1
  imosh::stack_trace "error status: ${exit_code}"
}

trap '__imosh::error_handler' ERR

__imosh::exit_handler::atexit() {
  # Stop checking exit statuses because this is inside exit_handler, and it is
  # impossible to output a stacktrace for an irregular exit status.
  set +e
  if [ -f "${__IMOSH_CORE_TMPDIR}/atexit.sh" ]; then
    source "${__IMOSH_CORE_TMPDIR}/atexit.sh"
  fi
}

__imosh::exit_handler() {
  local exit_code="$?"

  # Revert the EXIT trap to prevent an infinite loop.
  trap - EXIT

  # Output a stacktrace if the script does not output a stacktrace for the
  # error.  (signal_handler may output a stacktrace before calling this.)
  if (( exit_code && ! __IMOSH_STACK_TRACED )); then
    imosh::stack_trace "Error status: ${exit_code}"
  fi

  # Check the current process is not the root process so as not to remove the
  # root process's temporary directory.
  local pid=''
  func::getmypid pid
  if [ "${pid}" != "${IMOSH_ROOT_PID}" ]; then
    LOG INFO 'Finalizing a child process...'
    return
  fi

  __imosh::exit_handler::atexit &
  if ! wait "$!"; then
    LOG ERROR 'Failed to run atexit entirely.'
  fi
  rm -R -f "${IMOSH_TMPDIR}"

  # Close log pipes.
  exec 101>&- 102>&- 103>&- 104>&-
}

trap '__imosh::exit_handler' EXIT

__imosh::signal_handler() {
  local signal="$1"
  trap - "${signal}"
  local pid=''
  func::getmypid pid
  if [ "${pid}" = "${IMOSH_ROOT_PID}" ]; then
    __sub::exit "${pid}" "${pid}"
    if [ -f "${__IMOSH_CORE_TMPDIR}/EXIT" ]; then
      exit "$(cat "${__IMOSH_CORE_TMPDIR}/EXIT")"
    fi
  fi
  LOG ERROR "$(imosh::stack_trace "Terminated by signal: ${signal}" 2>&1)"
  kill -s "${signal}" "${pid}"
}

if ! shopt login_shell >/dev/null; then
  for signal in SIGHUP SIGINT SIGPIPE SIGTERM \
                SIGXCPU SIGXFSZ SIGUSR1 SIGUSR2; do
    trap "__imosh::signal_handler ${signal}" "${signal}"
  done
fi

# Close descriptors for logs beforehand for BASH3's bug.
exec 101>&- 102>&- 103>&- 104>&-
# Open descriptors for LOG without calling init_log.
exec 101>/dev/null 102>/dev/null 103>/dev/null 104>/dev/null
# Redirect log output to the current STDERR.
exec 105>&-
exec 105>&2

# Prepares a temporary directory and sets its path to TMPDIR.
TMPDIR="${TMPDIR:-/tmp}"
TMPDIR="${TMPDIR%/}"
export TMPDIR="${TMPDIR}/imosh.${RANDOM}.${RANDOM}.${RANDOM}.${RANDOM}"
export IMOSH_TMPDIR="${TMPDIR}"
export __IMOSH_CORE_TMPDIR="${TMPDIR}/.imosh"
if ! mkdir -p "${__IMOSH_CORE_TMPDIR}"; then
  LOG FATAL "Failed to create a temporary directory: ${__IMOSH_CORE_TMPDIR}"
fi

if sub::isset IMOSH_USE_DEFINE_FLAGS && (( IMOSH_USE_DEFINE_FLAGS )); then
  DEFINE_bool --group=imosh --alias=h help false \
      'Print this help message and exit.'
  DEFINE_bool --group=imosh helpfull false \
      'Print all the help message.'
  DEFINE_bool --group=imosh 'alsologtostderr' false \
      'Log messages go to stderr in addition to logfiles.'
  DEFINE_bool --group=imosh 'logtostderr' false \
      'Log messages go to stderr instead of logfiles.'
  DEFINE_string --group=imosh 'log_dir' '' \
      'Directory to output log files.  Output no files if this flag is empty.'
  DEFINE_string --group=imosh 'stacktrace_threshold' 'FATAL' \
      'Threshold to show stacktrace.'
  DEFINE_string --group=imosh 'help_format' '' \
      'Help format to output.'
  DEFINE_string --group=imosh 'imosh_test' '' \
      'Test files to test.'
else
  :

# This is automatically generated by print-flag-variables.
FLAGS_alsologtostderr=0
FLAGS_h=0
FLAGS_help=0
FLAGS_help_format=
FLAGS_helpfull=0
FLAGS_imosh_test=
FLAGS_log_dir=
FLAGS_logtostderr=0
FLAGS_stacktrace_threshold=FATAL
__IMOSH_FLAGS=([0]="IMOSH:help" [1]="IMOSH:helpfull" [2]="IMOSH:alsologtostderr" [3]="IMOSH:logtostderr" [4]="IMOSH:log_dir" [5]="IMOSH:stacktrace_threshold" [6]="IMOSH:help_format" [7]="IMOSH:imosh_test")
__IMOSH_FLAGS_ALIASES=([0]="help:h")
__IMOSH_FLAGS_DEFAULT_alsologtostderr=--alsologtostderr=false
__IMOSH_FLAGS_DEFAULT_help=--help=false
__IMOSH_FLAGS_DEFAULT_help_format='--help_format='\'''\'''
__IMOSH_FLAGS_DEFAULT_helpfull=--helpfull=false
__IMOSH_FLAGS_DEFAULT_imosh_test='--imosh_test='\'''\'''
__IMOSH_FLAGS_DEFAULT_log_dir='--log_dir='\'''\'''
__IMOSH_FLAGS_DEFAULT_logtostderr=--logtostderr=false
__IMOSH_FLAGS_DEFAULT_stacktrace_threshold='--stacktrace_threshold='\''FATAL'\'''
__IMOSH_FLAGS_DESCRIPTION_alsologtostderr='Log messages go to stderr in addition to logfiles.'
__IMOSH_FLAGS_DESCRIPTION_help='Print this help message and exit. (Alias: --h)'
__IMOSH_FLAGS_DESCRIPTION_help_format='Help format to output.'
__IMOSH_FLAGS_DESCRIPTION_helpfull='Print all the help message.'
__IMOSH_FLAGS_DESCRIPTION_imosh_test='Test files to test.'
__IMOSH_FLAGS_DESCRIPTION_log_dir='Directory to output log files.  Output no files if this flag is empty.'
__IMOSH_FLAGS_DESCRIPTION_logtostderr='Log messages go to stderr instead of logfiles.'
__IMOSH_FLAGS_DESCRIPTION_stacktrace_threshold='Threshold to show stacktrace.'
__IMOSH_FLAGS_IS_DEFAULT_alsologtostderr=1
__IMOSH_FLAGS_IS_DEFAULT_h=1
__IMOSH_FLAGS_IS_DEFAULT_help=1
__IMOSH_FLAGS_IS_DEFAULT_help_format=1
__IMOSH_FLAGS_IS_DEFAULT_helpfull=1
__IMOSH_FLAGS_IS_DEFAULT_imosh_test=1
__IMOSH_FLAGS_IS_DEFAULT_log_dir=1
__IMOSH_FLAGS_IS_DEFAULT_logtostderr=1
__IMOSH_FLAGS_IS_DEFAULT_stacktrace_threshold=1
__IMOSH_FLAGS_TYPE_alsologtostderr=BOOL
__IMOSH_FLAGS_TYPE_h=BOOL
__IMOSH_FLAGS_TYPE_help=BOOL
__IMOSH_FLAGS_TYPE_help_format=STRING
__IMOSH_FLAGS_TYPE_helpfull=BOOL
__IMOSH_FLAGS_TYPE_imosh_test=STRING
__IMOSH_FLAGS_TYPE_log_dir=STRING
__IMOSH_FLAGS_TYPE_logtostderr=BOOL
__IMOSH_FLAGS_TYPE_stacktrace_threshold=STRING

fi

__IMOSH_IS_LOADED=1

if sub::is_main; then
  eval "${IMOSH_INIT}"
  imosh::test_files "$@"
fi

